\documentclass[11pt,twoside,a4paper]{book}
\usepackage{czech}
\usepackage[latin2]{inputenc}
\usepackage{graphics}
\usepackage{array}
\usepackage{float}            % floating boxes (i.e. images)
\usepackage{a4wide}           % wider page layout
\usepackage{fancyhdr}         % control header & footer
\usepackage{sectsty}          % section header customization
\usepackage[numbers]{natbib}  % enhanced citation references
\usepackage{pgfplots}         % plots
\usepackage{listings}         % code listings
\usepackage{eurosym}          % symbol of the now-infamous currency
\usepackage{fancyvrb}         % verbatim in footnotes
\usepackage[top=3.6cm,bottom=3.5cm,inner=3.5cm,outer=2.6cm]{geometry} %custom page layout
\usepackage[bookmarks=true,unicode]{hyperref}

\graphicspath{{resource/}} % SVG converted images in subdirectory - see http://ctan.sqsol.co.uk/info/svg-inkscape/InkscapePDFLaTeX.pdf

\usetikzlibrary{patterns}

\sectionfont{\sffamily}
\chapterfont{\sffamily}

\fancypagestyle{plain}{
	\fancyhf{}
	\renewcommand{\headrulewidth}{0pt}
	\fancyfoot[CE,CO]{\thepage}
}

\renewcommand{\chaptermark}[1]{\markboth{\chaptername\ \thechapter.\ #1}{}}
\renewcommand{\sectionmark}[1]{\markright{\thesection\ #1}}

% No headers on empty pages before new chapter - http://www.markschenk.com/tensegrity/latexexplanation.html
\makeatletter
\def\cleardoublepage{\clearpage\if@twoside \ifodd\c@page\else
    \hbox{}
    \thispagestyle{plain}
    \newpage
    \if@twocolumn\hbox{}\newpage\fi\fi\fi}
\makeatother \clearpage{\pagestyle{plain}\cleardoublepage}

\setlength{\skip\footins}{1.5em}

% caption spacing adjustment
\setlength{\abovecaptionskip}{6pt}
\setlength{\belowcaptionskip}{6pt}

% settings for listings
\renewcommand*{\lstlistingname}{Vıpis}

\lstset{
	basicstyle=\fontsize{10}{12}\selectfont,
	numbers=left,
	showstringspaces=false
}

% allow usage of \verb in footnotes
\VerbatimFootnotes

\begin{document}
\pagenumbering{roman}

\begin{titlepage}
\begin{center}
\vspace*{\stretch{2}}
{\Huge\sffamily\bfseries Podpora vıvoje rozšíøení PHP CMS}

\vspace*{2em}
{\Large\sffamily\bfseries Martin Schmied}

\vspace*{\stretch{0.7}}
\resizebox{0.4\textwidth}{!}{\includegraphics{resource/vse-logo.png}}

\vspace*{\stretch{3}}
\end{center}
\end{titlepage}

\tableofcontents 

\cleardoublepage
\pagenumbering{arabic}

\chapter*{Úvod} \addcontentsline{toc}{chapter}{Úvod}
Web vznikl na poèátku devadesátıch let minulého století jako místo pro snadné sdílení informací formou vzájemnì propojenıch dokumentù. Za dvacet let své existence prošel mnoha promìnami. Posun od webu èistì informaèního k webu aplikaènímu udìlal z webového prohlíeèe jeden z nejdùleitìjších (a v urèitıch pøípadech prakticky jedinı) program potøebnı k produktivní práci i pro zprostøedkování zábavy. Pøes všechny tyto zmìny je dnešní web stále, stejnì jako v dobách svého vzniku, pøedevším platformou pro sdílení informací.

I v oblasti webového obsahu však došlo k bouølivému vıvoji a to jak na stranì vydavatelù, tak na stranì konzumentù. Postupem èasu rapidnì vzrostl vıznam multimediálního obsahu, kterı je navíc potøeba ve velmi krátkıch intervalech obmìòovat èi doplòovat. Model webu, na kterém jsou jednotlivé HTML dokumenty ruènì vytváøeny a upravovány lidmi brzy pøestal vyhovovat vzrùstajícím nárokùm na interaktivitu a aktuálnost. Brzy zaèaly vznikat aplikace zamìøené na správu webového obsahu (\emph{Content Management Systems} -- CMS), aby ulehèily práci vydavatelùm a poskytly dodateèné sluby konzumentùm.

Na poli systémù typu CMS bychom nalezli nepøeberné mnoství komerèních øešení. Vedle nich ale existuje také nezanedbatelné mnoství open source systémù, z nich nìkolika nejvìtším patøí velmi vıznamnı podíl na svìtovém webu.\footnote{Kupøíkladu k 15.5.2011 pohání dle prohlášení na domovské stránce \url{http://www.joomla.org} open source systém Joomla 2.7\,\% celého webu.} Základem úspìchu open source CMS je aktivní komunita uivatelù a vıvojáøù. Základní distribuce tìchto systémù pøedstavují pouze jádro, které lze pomocí velkého mnoství rozšíøení pøizpùsobovat konkrétním poadavkùm tvùrcù webového obsahu.

Tato práce se zamìøuje na nedílnou souèást zdravé komunity kolem open source CMS -- vıvojáøe jejich rozšíøení. Pøesnìji na efektivitu jejich práce. Ta je závislá nejen na kvalitì jádra CMS a pokroku webu jako takového, ale také na kvalitì jejich vıvojáøskıch nástrojù. I v této oblasti dochází k prùbìnému zlepšování, je ve svém dùsledku vede k širší nabídce lepších (a nìkdy levnìjších) rozšíøení. Z toho pak profitují nejen tvùrci obsahu, ale nepøímo všichni uivatelé webu. Souèasná úroveò dostupnıch vıvojáøskıch nástrojù však v mnoha ohledech není ideální. Cílem této práce  je identifikace problematickıch oblastí pøi vıvoji rozšíøení CMS systémù se zamìøením na specifika systému Joomla\footnote{Oficiální název systému je \uv{Joomla!} -- kvùli moné zámìnì s interpunkcí bude v prùbìhu práce uvádìn bez koncového vykøièníku.}. Vısledkem by mìl bıt návrh a prototypová implementace nástrojù pro usnadnìní vıvoje rozšíøení systému Joomla ve vıvojovém prostøedí Eclipse.

\chapter{Vıvoj rozšíøení pro PHP CMS}
Primární cílovou skupinou open source CMS nebyly v dobì jejich vzniku velké korporace a jejich webové portály. Mnoho jich zaèínalo na pøesnì opaèném konci spektra -- u osobních stránek a zápisníkù. Tady slavily velké úspìchy a nìkteré systémy tuto orientaci dodnes neopustily. Není proto pøekvapením, e nejrozšíøenìjší open source CMS jsou postaveny nad platformou PHP, která se ji dlouhou dobu vyznaèuje širokou nabídkou hostingovıch slueb, z nich velké mnoství je nabízeno zdarma èi za symbolickı poplatek. Kombinace PHP hostingu zdarma a open source CMS je tak pro mnoho lidí nejsnazší a nejlevnìjší cestou k vlastní webové prezentaci.

Obrázky \ref{fig:cmsdownloads} a \ref{fig:cmsinstallations} ukazují porovnání popularity open source CMS podle poètu staení a podle poètu instalací zjištìnıch v prùzkumu trního zastoupení tìchto systémù provedeného agenturou water\&stone v roce 2010 \citep[viz][]{shreves10}. I kdy se poøadí jednotlivıch systémù liší dle zvoleného kritéria popularity, je zøejmé, e velká vìtšina trního podílu pøipadá PHP CMS. Dále si mùeme všimnout tøí nejpopulárnìjších open source CMS, jimi jsou WordPress, Joomla a Drupal. Právì u nich budeme zkoumat monosti rozšiøování a doporuèené postupy pro vıvojáøe rozšíøení. Nejprve se ale podívejme na nástroje pro podporu vıvoje na platformì PHP, pro kterou jsou všechny tyto systémy urèeny.

\begin{figure}[h]
\centering
\begin{tikzpicture}
\begin{axis}[
    symbolic y coords={Umbraco [PHP],Alfresco [Java],eZ Publish [PHP],Typo3 [PHP],Liferay [Java],CMSMadeSimple [PHP],DotNetNuke [ASP.NET],Drupal [PHP],Joomla [PHP],WordPress [PHP]},
    scaled x ticks=false,
    ytick=data]
    \addplot[xbar,draw=blue,pattern=horizontal lines light blue] coordinates {
        (983625,WordPress [PHP])
        (113836,Joomla [PHP])
        (33671,Drupal [PHP])
        (13000,DotNetNuke [ASP.NET])
        (9948,CMSMadeSimple [PHP])
        (9435,Liferay [Java])
        (7461,Typo3 [PHP])
        (7031,eZ Publish [PHP])
        (7000,Alfresco [Java])
        (5420,Umbraco [PHP])
    };
\end{axis}
\end{tikzpicture}
\caption{Prùmìrnı poèet staení za jeden tıden bìhem roku 2010. \citep{shreves10}} \label{fig:cmsdownloads}
\end{figure}

\begin{figure}[h]
\centering
\begin{tikzpicture}
\begin{axis}[
    symbolic y coords={Concrete5 [PHP],Alfresco [Java],CMSMadeSimple [PHP],Tiky [PHP],Typo3 [PHP],Liferay [Java],DotNetNuke [ASP.NET],Drupal [PHP],WordPress [PHP],Joomla [PHP]},
    ytick=data]
    \addplot[xbar,draw=blue,pattern=horizontal lines light blue] coordinates {
        (1297,Joomla [PHP])
        (1012,WordPress [PHP])
        (575,Drupal [PHP])
        (402,DotNetNuke [ASP.NET])
        (154,Liferay [Java])
        (122,Typo3 [PHP])
        (82,Tiky [PHP])
        (72,CMSMadeSimple [PHP])
        (70,Alfresco [Java])
        (62,Concrete5 [PHP])
    };
\end{axis}
\end{tikzpicture}
\caption{Poèet instalací zjištìnıch v anketì agentury water\&stone.	 \citep{shreves10}} \label{fig:cmsinstallations}
\end{figure}

\section{Nástroje pro podporu vıvoje v PHP}
PHP patøí mezi nejpopulárnìjší programovací jazyky. V kvìtnu 2011 se jazyk PHP na ebøíèku TIOBE Programming Community Index\footnote{TIOBE Programming Community Index mìøí popularitu programovacích jazykù na základì poètu vısledkù vrácenıch vyhledávacími slubami pro dotazy na jednotlivé jazyky.} umístil na páté pozici za Javou, C, C++ a C\# \citep{tiobe}. Dle tìchto vısledkù se tak jedná o nejpopulárnìjší dynamicky typovanı jazyk vùbec. Právì dynamickı skriptovací charakter PHP má zásadní vliv na volbu nástrojù pro podporu vıvoje, jak bude ukázáno dále.

Hlavním zamìøením PHP je vıvoj webovıch aplikací. Samotné jádro PHP poskytuje pouze elementární podporu pro tento typ vıvoje a pro praktické vyuití je proto více ne ádoucí vyuití nìkterého z aplikaèních frameworkù, nebo alespoò nìkterıch rozšiøujících knihoven. Aèkoliv PHP pùvodnì není objektovì orientovanı jazyk (a jeho objektová nadstavba byla do verze PHP5 pøinejmenším problematická), dnešní nejrozšíøenìjší frameworky nabízejí primárnì objektovì orientované API\footnote{Podle prùzkumu popularity PHP frameworkù publikovaném na DZone.com \citep[viz][]{phpfrmwpoll} jsou nerozšíøenìjší Zend Framework, Symfony, CodeIgniter a CakePHP. Zajímavım fenoménem v pøípadì PHP však zùstává velké mnoství privátních mini-frameworkù, je jsou udrovány pouze pro vyuití v rámci jedné spoleènosti èi dokonce jedinım vıvojáøem -- ty pak v mnoha pøípadech objektovıch vlastností jazyka vùbec nevyuívají.}. V kontextu vıvoje rozšíøení pro open source CMS pak mùeme jako framework chápat CMS samotné.

V oblasti nástrojù pouívanıch pøi vıvoji PHP aplikací bychom jen stìí hledali všeobecnì doporuèenı, univerzálnì vyuitelnı mix nástrojù. To je dáno mnostvím faktorù -- zmiòme alespoò nìkteré:
\begin{itemize}
\item Dynamickı charakter jazyka neumoòuje vytvoøení stejnì kvalitních editaèních nástrojù, jaké jsou k dispozici pro staticky typované jazyky. Schopnosti kontextové nápovìdy jsou i u profesionálních nástrojù znaènì omezené, automatickı refaktoring nespolehlivı a podobnì.
\item Dlouhou dobu nebyly pro PHP k dispozici kvalitní vıvojová prostøedí (dále IDE -- Integrated Development Environment) zdarma. Pro mnoho vıvojáøù je pøitom PHP prvním jazykem, se kterım se v ivotì setkají -- jeliko nemají zkušenosti se staticky typovanımi jazyky, ve kterıch jsou vıhody IDE nedocenitelné, a èasto také nechtìjí investovat prostøedky do komerèních nástrojù, uchylují se èasto k editorùm s pouze základní funkèností jako je zvırazòování syntaxe.
\item V neposlední øadì hraje svou roli rozdílnost jednotlivıch aplikaèních frameworkù, nad kterımi jsou PHP aplikace vystavìny. Nìkteré (napø. Symfony) vyuívají rozhraní pro pøíkazovou øádku umoòující automatické generování kódu a úpravy konfigurací, jiné spoléhají èistì na ruènì psanı kód. Nìkteré vynucují striktní organizaci definic tøíd a nabízejí jejich automatické naèítání, jiné nechávají naèítání tøíd na zodpovìdnosti programátora.
\end{itemize}

\noindent Pøes všechny odlišnosti pøi vıvoji rozliènıch typù aplikací bychom našli nìkolik typù nástrojù, které jsou pro vıvoj v PHP buï nezbytné, nebo lze jejich pouití pøinejmenším doporuèit. Dále je uveden jejich pøehled v poøadí podle subjektivní dùleitosti z mého pohledu. V pøehledu je vynecháno bìhové prostøedí pro testování vyvíjenıch aplikací, jeho podoba se bude lišit v závislosti na typu aplikace\footnote{Typickı základ bìhového prostøedí pro webové aplikace v PHP je Apache web server s PHP interpretrem a relaèní databáze MySQL}.

\subsection{Editor}
Základním nástrojem nutnım pro vıvoj PHP aplikací je editor zdrojového kódu. I kdy lze pro tento úèel teoreticky vyuít jakıkoli editor umoòující úpravy prostého textu, je kvùli vyšší produktivitì více ne ádoucí vyuívat editory s pokroèilejšími funkcemi. Mezi základní funkce editoru zvyšující produktivitu vıvoje patøí napøíklad zvırazòování syntaxe, šablony pro bìnì pouívané konstrukce nebo automatické formátování. Nìkteré z tìchto funkcí najdeme i u pomìrnì jednoduchıch multifunkèních editorù\footnote{Do této kategorie mùeme zaøadit napøíklad jEdit, Notepad++, nebo v Èeské republice oblíbenı PSPad.} podporujících editaci zdrojového kódu v rùznıch programovacích jazycích. Pokroèilé funkce, u kterıch je velká èást implementace v editoru specifická pro konkrétní programovací jazyk, jsou potom a na vıjimky dostupné jen u komplexnìjších nástrojù spadajících do kategorie IDE. K tìmto funkcím patøí napøíklad kontextová nápovìda, automatickı refaktoring a integrace s debuggerem.

Jeliko je PHP témìø vıhradnì vyuíváno k vıvoji webovıch aplikací, musí editor umoòující produktivní práci podporovat nejen editaci PHP skriptù, ale i HTML stránek, CSS stylù a JavaScriptu. Pøi porovnání jednoduchıch multifunkèních editorù a IDE je v pøípadì tìchto dalších jazykù situace podobná jako u PHP samotného -- základní funkcionalitu nabízejí témìø všechny nástroje, pokroèilé funkce pouze IDE.

I pøes veškeré vıhody IDE\footnote{Je korektní zmínit, e vyuití IDE mùe mít i urèité nevıhody -- napøíklad velkou sloitost a malou flexibilitu. Èasto se také stává, e je IDE \uv{pøíliš chytré} -- napøíklad bude hlásit jakoukoliv neukonèenou znaèku v XHTML souboru jako chybu, co se zdá bıt v poøádku do doby, ne potøebujete v jednom souboru uloit šablonu zaèátku stránky.} stále velké mnoství PHP vıvojáøù vyuívá k editaci zdrojového kódu multifunkèních editorù. Najde se ale i øada vıvojáøù vyuívající pokroèilé funkcionality IDE. Tìm je k dispozici nìkolik komerèních produktù a dvì open source øešení vzešlá z populárních IDE primárnì urèenıch pro programovací jazyk Java -- Eclipse a NetBeans. Eclipse zároveò slouí jako základ pro dvì další IDE -- komerèní Zend Studio a open source Aptana Studio.

\subsection{Nástroj pro správu verzí}
Dalším nástrojem, bez kterého si lze jen tìko pøedstavit jakıkoliv praktickı vıvoj SW je VCS (Version Control System) nástroj. V pøípadì VCS je situace v PHP stejná jako u jakéhokoli jiného programovacího jazyka -- lze vyuít kterıkoliv existující VCS podporovanı na operaèním systému pouívaném pøi vıvoji. Pøi pouívání VCS lze pøitom typicky volit ze tøech typù uivatelskıch rozhraní:
\begin{itemize}
\item rozhraní pro pøíkazovou øádku,
\item samostatná aplikace nabízející grafické uivatelské rozhraní,
\item integrace VCS v IDE.
\end{itemize}

\noindent Pro uivatele IDE je samozøejmì nejpøíznivìjší tøetí varianta zpøístupòující funkce VCS a rozhraní pro vizualizaci rozdílù mezi verzemi uvnitø vıvojového prostøedí. Jistou nevıhodou je omezené mnoství VCS systémù podporovanıch v daném IDE, které omezuje jejich vzájemnou kombinovatelnost. V tomto ohledu jsou vıhodné velké otevøené IDE platformy (jako NetBeans a pøedevším Eclipse), pro nì existuje mnoho zásuvnıch modulù pro rùzné VCS systémy vyuitelné stejnì tak dobøe pro vıvoj v Javì jako v PHP, nebo jakémkoli jiném jazyku podporovaném na dané platformì.

\subsection{Debugger}
Mezi PHP vıvojáøi je stále pomìrnì rozšíøenou praktikou pøidávání ladících vıstupù do kódu namísto vyuívání debuggeru. Interaktivní ladìní s pomocí debuggeru je témìø vıhradnì dostupné pouze uivatelùm IDE\footnote{I kdy existují vıjimky z tohoto pravidla a jako front-end pro debugger lze se správnım zásuvnım modulem vyuít napøíklad i slavnı editor vim. \citep[viz][]{xdebugvim}}. I mezi nimi se však najdou mnozí, kteøí dají pøednost ladícím vıstupùm pøed debuggerem. Z pohledu efektivity práce je však vyuívání debuggeru ve vìtšinì pøípadù lepší zpùsob ladìní programu, zvláštì pak u komplexních aplikací. Je tak dalším argumentem pro pouívání IDE.

\subsection{Knihovna pro jednotkové testy}
Další nedostateènì rozšíøenou praktikou v PHP komunitì je tvorba jednotkovıch testù. Jejich (ne-)existence má pøitom zásadní dopad na kvalitu vısledného softwarového produktu, jeliko v kódu dobøe pokrytém jednotkovımi testy dochází k mnohem ménì neobjevenım regresím\footnote{Regrese v SW je situace, kdy úprava zdrojového kódu zpùsobí rozbití funkènosti, která pøed zmìnou fungovala dobøe. K regresím navíc èasto dochází na naprosto neèekanıch místech, která se zmìnou kódu, je je zpùsobila, zdánlivì nesouvisí.}. Automatické testování je pøitom u dynamickıch interpretovanıch jazykù ještì mnohem dùleitìjší, ne u staticky typovanıch kompilovanıch jazykù, ve kterıch je mnoho potenciálních chyb odhaleno bìhem pøekladu. Pro tvorbu jednotkovıch testù v PHP jsou k dispozici knihovny PHPUnit a SimpleTest. Podpora tìchto knihoven v IDE se rùzní, ale zpravidla je moné pøinejmenším spouštìní testù pøímo z IDE a prohlíení jejich vısledkù.

Jako doplnìk jednotkovıch testù (nebo do jisté míry jejich alternativu) lze vyuít nástrojù pro tvorbu webovıch testovacích scénáøù. Tyto nástroje umoòují skrze zásuvnı modul v prohlíeèi nahrát urèité chování uivatele na stránce a vytvoøit sadu testù na oèekávanı vıstup zpracování uivatelskıch akcí. Nahrané chování pak nástroj umí automaticky pøehrát v prohlíeèi vèetnì spuštìní testù správnosti vıstupu. Tyto nástroje jsou nezávislé na konkrétní technologii pouité na serveru\footnote{I kdy nìkteré nabízejí integraci s knihovnami pro psaní testù ve vybranıch jazycích. Scénáø lze pak pouštìt jako automatickı integraèní test.}. Ze zástupcù lze zmínit napøíklad Selenium èi Windmill.

\subsection{Nástroj pro automatizaci sestavování} \label{subsect:phing}
Nástroje pro automatizaci sestavování (tzv. \uv{build automation tools}) jsou témìø nezbytnou pomùckou pøi vıvoji jakékoliv sloitìjší aplikace v kompilovaném jazyku. Pomohou ovšem i s automatizací pøípravy distribuèního balíèku PHP aplikace, zejména pokud je souèástí sestavení pøíprava testovacího prostøedí a spouštìní automatickıch testù. Pøímo pro PHP je k dispozici nástroj Phing vycházející z Antu, nástroje primárnì urèeného pro automatizaci sestavení Java aplikací.

Pro rozsáhlejší èi dlouhodobìjší projekty je vhodné vyuít integraèního serveru, kterı mùe iniciovat sestavení distribuce (spolu se spuštìním testù) v pravidelnıch èasovıch intervalech (nebo napøíklad po commitu do VCS systému), emailem upozoròovat na selhávající testy a podobnì. Velmi flexibilním open source integraèním serverem vyuitelnım i pro vıvoj PHP aplikací je napøíklad Jenkins.

\subsection{Další nástroje}
Vıèet nástrojù vyuitelnıch pøi vıvoji PHP aplikací jistì není úplnı. Z dosud nezmínìnıch mùeme vybrat napøíklad nástroje pro generování dokumentace (napø. phpDocumentor), nástroje pro statickou analızu kódu (napø. PHP zásuvnı modul pro Sonar integrující více takovıch nástrojù) èi issue tracking systém (napø. Redmine). V závislosti na typu vyvíjené aplikace bychom pak tento seznam mohli dále rozšiøovat.

\section{Rozšíøení PHP CMS}
Podívejme se podrobnìji na monosti tvorby rozšiøování funkènost nejrozšíøenìjších open source CMS. Bude nás zajímat, jaké typy rozšíøení jsou pro danı systém k dispozici a jak se od sebe jednotlivé typy rozšíøení liší. V pøípadì funkèních rozšíøení prozkoumáme principy jejich integrace v CMS (tj. jakım zpùsobem mohou modifikovat existující funkcionalitu nebo pøidávat novou) a zpùsob zachycení metadat. Rozebereme si také proces instalace rozšíøení a podobu instalaèních balíèkù.

\subsection{WordPress}
Primárním zamìøením systému WordPress jsou osobní webové prezentace a zápisníky (tzv. blogy). Samotné jádro systému pokrıvá mnohem ménì funkcionality ne v pøípadì Drupalu èi Joomly\footnote{WordPress vystaèí v základní instalaci s pouhımi 12 tabulkami v databázi oproti 33 v pøípadì Joomly a 73 u Drupalu. I kdy mezi poètem tabulek a sloitostí CMS zdaleka nemusí platit pøímá úmìra, rozdíl je zde na první pohled patrnı.}. Témìø 15\,000 dostupnıch zásuvnıch modulù však umoòuje vytvoøit z WordPressu plnohodnotnı CMS.

Do WordPressu lze instalovat dva typy rozšíøení -- témata (Themes) a zásuvné moduly (\mbox{Plugins}). Témata slouí k pøizpùsobení vzhledu systému. Z hlediska této práce nás budou více zajímat funkèní rozšíøení, tedy zásuvné moduly. Jejich nabídku je moné procházet pøímo z administraèní èásti systému a vybraná rozšíøení rovnou instalovat. Instalaci lze provést té manuálnì staením archivu s rozšíøením a následnım rozbalením do pøedem dané sloky. Po instalaci je zásuvnı modul zobrazen v pøíslušném seznamu v administraci, ale zatím není aktivován. Teprve aktivací se modul stává funkèním a mùe upravovat èi rozšiøovat funkce CMS.

Integrace zásuvného modulu se zbytkem systému probíhá registrací funkcí, které mají bıt zavolány v urèitém okamiku (napø. aktivace nebo v prùbìhu vykreslování rùznıch èástí stránky). Modul tak mùe reagovat na nìkteré události nebo pozmìòovat koneènou podobu vykreslované stránky. Alternativní zpùsob integrace je skrze poskytování speciálních znaèek, které je moné vyuít v šablonách stránek a jejich zpracování je poté na modul delegováno. \citep{wp-pluginhowto}

Samotnı zásuvnı modul mùe bıt tvoøen pouze jedinım souborem. V pøípadì modulù obsahujících více souborù je vdy jeden PHP skript hlavním souborem modulu. Ten je spuštìn po instalaci a má monost zaregistrovat poèáteèní posluchaèe na události (typickı modul se zaregistruje alespoò na upozornìní pøi aktivaci a deaktivaci). Hlavní soubor modulu musí obsahovat hlavièku, ve které jsou formou strukturovaného blokového komentáøe uvedena metadata modulu. Podporovaná metadata a formu jejich zápisu je vidìt v šablonì hlavièky zásuvného modulu na vıpisu \ref{lst:wp-plugin-header}. \citep{wp-pluginhowto}

\lstinputlisting[language=PHP, caption={Šablona hlavièky zásuvného modulu systému WordPress. \citep{wp-pluginhowto}}, label=lst:wp-plugin-header]{listings/cms-extension-metadata/wp-plugin-header.php}

\subsection{Drupal} \label{subsect:drupal-extensions}
Drupal má podobnì jako WordPress dva hlavní typy rozšíøení -- moduly (Modules) a témata (Themes). Analogicky jako v pøípadì WordPressu slouí témata k pøizpùsobení vzhledu a moduly pøedstavují funkèní rozšíøení. Pro instalaci nového modulu staèí stáhnout archiv s distribucí a rozbalit ho do speciální sloky v adresáøovém stromu systému. Modul je pak zobrazenı v pøíslušném seznamu v administraèní èásti systému, kde je ho stejnì jako v systému WordPress potøeba aktivovat.

První verze Drupalu vznikaly v dobì pøed vydáním PHP5, kdy objektovı model jazyka trpìl mnoha problémy. To je jeden z dùvodù, proè vìtšina základních API nevyuívá objektovì orientovanıch konstruktù \citep{drupal-oop}. Princip integrace modulù se zbytkem systému je principiálnì shodnı s WordPressem. Namísto aktivní registrace na události se však spoléhá na jmennou konvenci -- rùzné èásti systému èi jiné moduly definují body pro rozšíøení s názvem zaèínajícím \uv{hook\_} (npø. \verb|hook_install|) a modul pak mùe toto rozšíøení implementovat vytvoøením funkce stejného názvu, ve kterém však \uv{hook} nahradí jménem modulu. Tyto rozšiøující funkce by mìly bıt deklarovány v rámci hlavního PHP skriptu souboru nazvaného \verb|jméno_modulu.module|. \citep{drupal-moduledev}

Instalaèní, aktualizaèní\footnote{Drupal obsahuje pøímou podporu pro snadnou migraci databázovıch schémat mezi rùznımi verzemi modulu.} a odinstalaèní funkce, pokud jsou potøeba, se nedávají do hlavního skriptu modulu, ale do speciálního souboru \verb|jméno_modulu.install|. Kadı modul ještì navíc obsahuje soubor se základními metadaty ve formátu INI file s názvem \verb|jméno_modulu.info|. Vedle základních metadat jako je jméno a popis modulu musí bıt také specifikována podporovaná verze Drupalu. Od verze 7 je navíc nutné vypsat seznam všech souborù obsahujících definice tøíd (tento seznam je internì cachován a pøi jeho zmìnì bìhem vıvoje je nutné vymazat cache). Dále je moné specifikovat závislost na jinıch modulech, bez jejich pøítomnosti danı modul nelze aktivovat. Ukázka obsahu \verb|info| souboru je na vıpisu \ref{lst:drupal-module-info}. \citep{drupal-moduledev}

\lstinputlisting[caption={Pøíklad obsahu souboru s metadaty modulu pro CMS Drupal.}, label=lst:drupal-module-info]{listings/cms-extension-metadata/drupal-module-info.ini}

\subsection{Joomla}
Systém rozšíøení CMS Joomla se od vıše zmínìnıch konkurenèních CMS v mnohém liší. Z pohledu vıvojáøe je zajímavı objektovì orientovanı design jádra systému. Vìtšina API vyuívanıch pøi tvorbì rozšíøení vyuívá objektovıch rysù jazyka. Zøejmì nejvìtší odlišností postihující jak uivatele, tak vıvojáøe, je existence více specializovanıch typù funkèních rozšíøení. Podívejme se teï na jejich struènı pøehled \citep{mastering-joomla}:

\begin{description}
	\item[Komponenty (Components)] Slouí pro vykreslování hlavní obsahové èásti stránky. Komponenta je tak nejdùleitìjším a z pohledu uivatele \uv{nejmocnìjším} typem rozšíøením. API pro komponenty je implementací návrhového vzoru Model--View--Controller (MVC) umoòujícímu napøíklad znovupouitelnost velké èásti kódu pøi zmìnì prezentaèní technologie. Nìkteré komponenty tak nabízejí alternativní formáty vıstupu (napø. HTML a PDF). Jiné dokonce vùbec vıstup v HTML nepodporují a vytváøejí komunikaèní uzel pro pøipojení externích aplikací\footnote{Nejèastìjším pøíkladem komunikace jiné aplikace s CMS je zøejmì asynchronní volání z JavaScriptu umístìného na webové stránce vykreslené Joomlou. Serverová èást obsluhující klientské poadavky pak bude s velkou pravdìpodobností komponenta.}. Kadá komponenta je navíc rozdìlena na veøejnou èást pro pouití ve veøejnì dostupné èásti webu a na administraèní èást umoòující zmìnu konfigurace komponenty.

	\item[Moduly (Modules)] Pouívají se k vykreslování menších èástí obsahu webové stránky, které se zobrazují po stranách hlavního obsahu, pøípadnì nad èi pod ním. Pøíkladem modulu je seznam naposledy publikovanıch èlánkù èi navigaèní menu. Èasté je vyuití modulù jako doplòkù komponent.

	\item[Pluginy (Plugins)]\footnote{Èeskı vıraz \uv{zásuvnı modul} je v kontextu rozšíøení systému Joomla ponìkud nepraktickı kvùli zámìnì s \uv{moduly}. Proto bude tento druh rozšíøení oznaèován jako plugin.} Slouí k úpravì chování jádra systému a nìkterıch rozšíøení. Mohou toti reagovat na rùzné události. Zatímco v pøípadì WordPressu a Drupalu je tato monost dopøána všem funkèním rozšíøením (pøipomeòme si, e u nich existuje jen jedinı druh funkèních rozšíøení), v pøípadì Joomly je vısadou právì pluginù. Bìné je také vyuití pluginù jako knihoven PHP skriptù.
\end{description}

\noindent V pøípadì Joomly nelze provést instalaci rozšíøení jednoduchım rozbalením do správného adresáøe uvnitø CMS. Místo toho jsou rozšíøení distribuovány ve formì speciálních instalaèních balíèkù, které je potøeba pøes instalaèní stránku v administraèní èásti systému nahrát na server. Bìhem instalace jsou soubory z instalaèního balíèku rozbaleny do adresáøového stromu CMS a to èasto na více rùznıch míst. Napøíklad u komponenty jsou soubory z administraèní èásti po instalaci oddìlené od zbytku komponenty. Koneèné umístìní jednotlivıch souborù v adresáøovém stromu Joomly tak záleí na druhu rozšíøení (pøièem mezi rùznımi druhy není konzistentní) a také na typu daného souboru. Z uivatelského pohledu mùe bıt toto rozdìlování souborù jednoho rozšíøení nepodstatné, ale z pohledu vıvojáøe se jedná o zásadní komplikaci, jak bude diskutováno dále. Nainstalovaná rozšíøení lze v administrátorském rozhraní povolovat a zakazovat (pøesnı postup se liší podle druhu rozšíøení).

Je jasné, e k zabezpeèení takto \uv{chytrého} procesu instalace je potøeba více metadat, ne s jakımi si vystaèí WordPress nebo Drupal. Joomla proto u rozšíøení vyaduje XML manifest, ve kterém jsou v nìkolika skupinách vypsány všechny soubory (nebo celé sloky) je rozšíøení tvoøí. Kromì toho mùe manifest obsahovat i odkazy na instalaèní a odinstalaèní PHP skripty, SQL skripty pro vytvoøení a odstranìní databázovıch tabulek, definici poloek administrátorského menu èi specifikaci konfiguraèních parametrù. Nìkteré aspekty rozšíøení, které je v pøípadì WordPressu a Drupalu nutné øešit programovì, tak lze v Joomle vyøešit deklarativnì. Pøíklad XML manifestu komponenty je uveden na vıpisu \ref{lst:sample-component-manifest}.

\lstinputlisting[caption={Pøíklad manifestu komponenty urèené pro CMS Joomla ve verzi 1.5 \citep{sample-component-manifest}}, label=lst:sample-component-manifest]{listings/cms-extension-metadata/sample-component-manifest.xml}

\subsection{Shrnutí a porovnání} \label{subsect:cms-summary-and-comparison}
Tøi nejrozšíøenìjší open source CMS systémy mají mnoho spoleèného, ale také se v mnohém liší. Pøi porovnání dle zkoumanıch kritérií, jejich shrnutí nabízí tabulka \ref{tab:cms-comparison}, zjistíme velkou podobnost mezi systémy WordPress a Drupal. Systém Joomla je od této dvojice naopak znaènì odlišnı.

\begin{table}[h]
	\centering
	\caption{Srovnání rùznıch aspektù rozšíøení PHP CMS}
	\label{tab:cms-comparison}
	\fontsize{10}{12}
	\selectfont
	\begin{tabular}{m{3.9cm} c c c}
		& \bfseries{WordPress} & \bfseries{Drupal} & \bfseries{Joomla} \\ \hline
		objektovì orientovaná základní API & ne & ne & ano \\ \hline
		funkèní rozšíøení & univerzální & univerzální & 3 druhy \\ \hline
		formát metadat & PHP komentáø & INI soubor & XML \\ \hline
		povinné vypsání souborù rozšíøení v metadatech & ne & obsahují-li definice tøíd & všechny \\ \hline
		instalace rozšíøení & rozbalením & rozbalením & z administraèního UI \\ \hline
		umístìní souborù rozšíøení po instalaci & 1 adresáø & 1 adresáø & rùzné adresáøe \\ \hline
	\end{tabular}
\end{table}

\noindent Zkusme se nyní zamyslet, jakı vliv mají nìkteré odlišnosti na sloitost vıvoje rozšíøení pro CMS disponující danou vlastností:

\begin{description}
	\item[objektovì orientovaná API] Nelze jednoznaènì øíci, jakım zpùsobem pøispívají objektová API k produktivitì vıvojáøe. Jistì se najde nemálo vıvojáøù, pro které je OOP (objektovì orientované programování) spíše pøekákou. Navíc pøi praktickém vıvoji jde spíše o kvalitu daného API a vestavìnıch mechanismù a otázka vyuití OOP je pak spíše technická. Tato práce se rozhodnì nezabıvá detailní kvalitativním analızou API pro vıvoj rozšíøení a tak se na vìc podívejme z technického pohledu. 
	
	OOP umoòuje lepší organizaci kódu, nebo pøináší další organizaèní jednotky. Tyto další organizaèní jednotky pak umoòují omezovat viditelnost tìch èástí kódu, které mají pouze lokální vıznam. Lepší organizace kódu a omezení viditelnosti (scoping) kódu pak umoòuje tvorbu lepších nástrojù. Je pravdìpodobné, e pouitím IDE dosáhneme vìtšího nárùstu produktivity právì u aplikací vyuívajících OOP. Automatické doplòování kódu bude v tomto pøípadì pøesnìjší, nebo z nabídek mohou bıt vyfiltrovány nabídky, které v daném kontextu nejsou dostupné.
	
	\item[více druhù funkèních rozšíøení] Opìt nelze s jistotou øíci, zda je z hlediska návrhu dobré èi špatné vyadovat striktní oddìlení jednotlivıch funkcí do rùznıch typù rozšíøení. Snadno ovšem nalezneme argumenty proti takovému oddìlení. Jasnou nevıhodou je vynucení tvorby více instalaèních jednotek i v pøípadì, e bez vzájemné souèinnosti nebudou funkèní. Jako pøíklad ze systému Joomla uveïme kombinaci pluginu pouitého jako knihovna a komponenty, je tento plugin (knihovnu) vyuívá. Komponenta bez uvedeného pluginu nikdy nebude fungovat a plugin sám o sobì nedìlá vùbec nic uiteèného. Pøesto je administrátor webu provozujícího systém Joomla nainstalovat tyto rozšíøení samostatnì\footnote{Ve verzi 1.6 je novì moné vytvoøit ze souvisejících rozšíøení jeden instalaèní balíèek -- archiv obsahující jednotlivé archivy s rozšíøeními a speciální instalaèní manifest.}. 
	
	Jeden univerzální druh funkèního rozšíøení je v tomto ohledu flexibilnìjší. Pokud je ádoucí oddìlit urèitou funkcionalitu do samostatného instalaèního balíèku (napø. protoe má doplòkovou funkci a ne všichni ji chtìjí vyuívat), mùeme toho jednoduše dosáhnout vytvoøením dvou samostatnıch rozšíøení. Pokud naopak oddìlování funkcionality nemá v daném kontextu vıznam, mùeme stále dosáhnout oddìlení jednotlivıch logickıch funkcí (tedy napø. po vzoru Joomly separace vykreslování hlavního obsahu, doplòkového obsahu a reakce na události) pomocí vnitøního strukturování jednoho rozšíøení.
	
	\item[povinné vypsání souborù v metadatech] Pokud se musí kadı soubor (nebo sloka) zaregistrovat v metadatech rozšíøení, je to jistì ztíení vıvoje a vytváøí to prostor pro vznik zbyteènıch chyb. Hlavní otázkou je, proè je tato registrace vyadována. V pøípadì Drupalu je to kvùli automatickému naèítání souborù s tøídami pøi jejich prvním pouití -- v tomto pøípadì tedy na jednu stranu dochází ke komplikaci (nesmím zapomenout zaregistrovat soubor obsahující definici tøídy), která ale na druhou stranu pøináší usnadnìní (pøi pouití tøíd se nemusím zabıvat naèítáním skriptù). Systém Joomla vyaduje registraci souborù kvùli instalaci. Dùvodem je, e adresáøová struktura instalaèního balíèku není po instalaci zachována. Tím se dostáváme k dalšímu bodu.
	
	\item[oddìlení souborù nainstalovaného rozšíøení] Tato zvláštnost systému Joomla má velmi neblahı vliv na vıvoj rozšíøení. Pøi vıvoji se toti neustále opakuje fáze úprav kódu na následného testování. Pro otestování rozšíøení PHP CMS musí bıt toto rozšíøení nainstalováno, co mimo jiné znamená pøítomnost souborù rozšíøení na správném místì v adresáøovém stromu CMS. Tyto soubory musí samozøejmì obsahovat poslední zmìny, které chceme testovat. Z toho vyplıvá, e pøi vıvoji buï editujeme pøímo soubory v adresáøovém stromu CMS, nebo editujeme soubory v oddìleném adresáøi, se kterım jsou soubory v CMS synchronizovány. V pøípadì WordPressu a Drupalu jsou obì monosti schùdné -- editace pøímo v CMS je jednoduché korektní øešení a pokud chceme z nìjakého dùvodu mít editované soubory mimo CMS, mùeme napøíklad vytvoøit v CMS symbolickı odkaz na sloku, ve které jsou obsaeny.
	
	V pøípadì systému Joomla je situace o dost sloitìjší, jeliko napøíklad soubory tıkající se jedné komponenty mohou bıt v adresáøovém stromu CMS nejménì na šesti místech v závislosti na jejich druhu. Pokud budeme soubory editovat pøímo v CMS, budeme èelit problému pøi pouití systému pro správu verzí. Pro jeho efektivní pouití je nutné mít soubory tvoøící funkèní celek v jednom spoleèném adresáøi. I v pøípadì pouití IDE budeme èelit problémùm -- z pohledu IDE by opìt jeden funkèní celek mìl odpovídat jednomu projektu. Navíc pøi vytváøení distribuce bude nutné soubory z CMS extrahovat, vytvoøit instalaèní balíèek a jeho manifest. Pokud budeme editované soubory rozšíøení dret v oddìleném adresáøi v rozloení odpovídajícím instalaènímu balíèku, musíme se postarat o synchronizaci tìchto souborù se soubory nainstalovaného rozšíøení ve stromu CMS. V tomto pøípadì máme øadu moností od reinstalace rozšíøení pøed kadım testováním (velmi nevhodné kvùli dlouhé dobì od zmìny k otestování) pøes vytvoøením a spouštìním skriptu, kterı se postará o zkopírování souborù (o nìco rychlejší) po udrování sady symbolickıch odkazù.
\end{description}

\section{Existující nástroje}
Koneènım cílem této práce je usnadnìní vıvoje rozšíøení CMS Joomla v Eclipse IDE. Ne se však pustíme do samotného návrhu a implementace pøíslušného rozšíøení Eclipse, bude nás zajímat souèasná nabídka nástrojù pro tento typ vıvoje a to zejména se zamìøením na podporu v IDE.

\subsection{Komerèní nástroje}
Podívejme se na dva zástupce komerèních nástrojù nabízející pøímou podporu vıvoje rozšíøení CMS. Prvním z nich je Adobe Dreamweaver -- aplikace nacházející se svım zamìøením nìkde na rozhraní komplexních IDE pro vıvoj webovıch aplikací a nástrojù pro vizuální návrh webovıch stránek. Ve verzi CS5 byla do Dreamweaveru pøidána podpora pro vıvoj CMS umoòující automatické nalezení souborù souvisejících s vykreslovanou stránkou pomocí sledování prùbìhu skriptu na vıvojovém serveru. Z vykreslené stránky je pak napøíklad moná pøímá navigace k definicím CSS stylùm, jejich zmìnu umí Dreamweaver promítnout i bez dalšího spouštìní skriptù na serveru. Schopnost vizualizace a propojení vıstupu se zdrojovımi soubory jdou daleko za monosti open source PHP IDE. Nástroj je však primárnì orientován na podporu vıvoje vizuálních témat, nikoliv funkèních rozšíøení. Pro mnoho potenciálních uivatelù (zejména tvùrcù nekomerèních rozšíøení) je pak odrazující pomìrnì vysoká cena\footnote{V kvìtnu 2011 je cena Adobe Dreamweaver CS5.5 v Adobe Download Store pro region vıchodní Evropy (\url{https://store2.adobe.com/cfusion/store/index.cfm?\&store=OLS-EU\#}) \EUR{449} bez DPH.}. \citep{dreamweaver-cms}

Druhım komerèním nástrojem, na kterı se blíe podíváme, je codeLobster PHP Edition, je mùeme bez problémù klasifikovat jako IDE. K dispozici jsou dvì varianty tohoto IDE, kde základní edice je k dispozici zdarma. Edice Professional pak navíc obsahuje podporu pro vybrané CMS systémy, aplikaèní frameworky a SQL. Podpora CMS WordPress, Drupal a Joomla se skládá pøedevším z následujících funkcí \citep{codelobster}:
\begin{itemize}
\item instalace a základní konfigurace CMS z IDE,
\item automatické doplòování kódu,
\item navigace k referenèní dokumentaci pøímo z kódu,
\item vizuální editor HTML šablon.
\end{itemize}

\noindent Zastavme se na chvíli u automatického doplòování. Urèité typy doplòování jsou vyuitelné univerzálnì v jakékoliv PHP aplikaci -- napø. seznam statickıch metod vybrané tøídy nebo seznam argumentù metody. Ve skriptovacím jazyku jako je PHP je ale bìné napøíklad vyuívání funkèních argumentù pøedstavujících mapování mezi klíèi a hodnotami (v PHP asociativní pole). I kdy je seznam pouitelnıch klíèù (a nìkdy hodnot) u dané mapy èasto pevnì danı, specifikovanı v referenèní dokumentaci, z pohledu IDE není tato informace ádnım zpùsobem obecnì odvoditelná. Pokud tedy budeme chtít vylepšit systém automatického doplòování o tyto pøípady, musíme tak uèinit formou rozšíøení specifického pro danı systém. codeLobster takovou podporu nabízí pro systémy WordPress a Drupal. U systému Joomla spoléhá na generickou podporu doplòování objektovì orientovaného orientovaného PHP kódu.

\subsection{Rozšíøení open source IDE}
Základem pro vıvoje rozšíøení PHP CMS v open source IDE (zamìøíme se na Eclipse a NetBeans) je vdy nadstavba daného IDE pro vıvoj v PHP. Existuje také nìkolik projektù pøidávajících pøímou podporu pro Drupal èi Joomlu, ale ke kvìtnu 2011 se dá za aktivní povaovat prakticky jedinı. Ostatní skonèily buï ještì pøed prvním vydáním, nebo krátce po nìm, kdy byla ještì vìtšina funkcionality ve fázi plánování. Podívejme se teï na nìkteré projekty a jejich realizované èi plánované vlastnosti.

\begin{description}
\item[Drupal plugin pro Eclipse od XTEND.US] První vydání na poèátku roku 2010 obsahovalo pouze svázání pøípon speciálních souborù pouívanıch v modulech Drupalu (napø. \verb|.module| a \verb|.install|, viz \ref{subsect:drupal-extensions}) s typem obsahu (Content Type) pro PHP skripty -- Eclipse se tak k tìmto souborùm zaène chovat stejnì, jako by mìly pøíponu \verb|.php| \citep{d4e-drupal-groups}. Toho lze dosáhnout i bez instalace tohoto pluginu do Eclipse pouhou zmìnou konfigurace -- instalace pluginu nás tak pouze ušetøí ruèních úprav konfigurace. Mnoho dalších funkcí bylo dle slov autora v dobì prvního vydání ve fázi prototypu èi v pøípravì. Mezi nimi strukturovanı editor pro \verb|.info| soubory, prùvodce pro vytvoøení novıch souborù specifickıch pro Drupal nebo nápovìda k funkcím z Drupal API \citep{d4e-eclipse-forums}. Od prvního vydání nedošlo k pøílišnému pokroku, ale autor stále jeví o projekt zájem, take ho ještì lze povaovat za aktivní. Nevıhodou projektu je uzavøená komerèní licence.

\item[NetBeans 6.5 Support for Drupal 6.x] Rozšíøení NetBeans IDE o monost vytvoøení projektu ze zdrojovıch souborù Drupalu (z CVS), prùvodce vytvoøením nového modulu èi tématu a doplòování pro dostupné body rozšíøení (hooks). První vydání na konci èervna 2008, poslední na konci prosince stejného roku. Není kompatibilní s aktuální verzí NetBeans (7.0). Rozšíøení je dostupné pod open source Common Development and Distribution License (CDDL; jedna z licencí samotnıch NetBeans). \citep{drupal-netbeans}

\item[JEclipse Summer of Code version] Prototyp vyvinutı v rámci Google Summer of Code v roce 2007 \citep{jeclipse-blog}. Obsahuje prùvodce pro zaloení nového modulu a komponenty a prùvodce pro export instalaèního balíèku. Zajišuje také funkènost automatického doplòování kódu u objektù z Joomla API \citep{jeclipse-userguide}. Závisí na staré verzi PHPEclipse a není tedy kompatibilní s Eclipse PDT\footnote{PHPEclipse je historicky starší, avšak stále aktivní projekt pøidávající podporu pro PHP do Eclipse. Je hostovanı na SourceForge.net. Novìjší PHP Development Tools Project (PDT) je naproti tomu rozvíjen pøímo pod køídly Eclipse Foundation a má tak statut \uv{oficiálního} rozšíøení pro PHP. PDT navíc staví na dalším Eclipse projektu Dynamic Languages Toolkit (DLTK), je poskytuje podporu pro tvorbu IDE pro dynamické programovací jazyky.}. Je dostupnı pouze zdrojovı kód a jednoduchı uivatelskı manuál shrnující implementovanou funkcionalitu (viz \citep{jeclipse-userguide}). Licenci ke zdrojovému kódu se nepodaøilo zjistit.

\item[J!Code] Projekt zaloenı se zámìrem vytvoøit IDE pro vıvoj rozšíøení Joomly. Jádrem projektu je distribuce EasyEclipse\footnote{EasyEclipse byl projekt zastøešující separátní distribuce Eclipse. Typickım znakem Eclipse je toti veliká modularita, ale spolu s ní velká roztøíštìnost jednotlivıch projektù. Cílem EasyEclipse tak bylo pøipravit bezproblémovì fungující distribuce Eclipse se všemi potøebnımi pluginy pro rùzné typy vıvoje a nièím navíc (to je samozøejmì vìc názoru). Poslední (pre-release) verze distribucí pochází z roku 2009. Na konci kvìtna 2011 byl projekt oficiálnì ukonèen. \citep[viz][]{easyeclipse}} s podporou pro PHP zaloenou na PHPEclipse. Pozdìji zøejmì došlo k integraci vıše zmínìného JEclipse. Jediná dostupná distribuce J!Code však JEclipse pøedchází -- je datována k 12.12.2006. Projekt mìl za cíl jednak vytvoøení distribuce IDE z existujících projektù a obecnıch nástrojù uiteènıch pøi vıvoji Joomla rozšíøení (napø. prohlíeè schématu databáze) a v pozdìjší fázi pak vytvoøení Eclipse pluginù specifickıch pro systém Joomla. Tato fáze zøejmì nikdy nebyla realizována. Zamıšlená funkcionalita zahrnovala plugin pro integraci referenèní dokumentace systému Joomla v systému nápovìdy Eclipse IDE, exportér pro vytvoøení instalaèních balíèkù a šablony pro nové Joomla komponenty. Pro J!Code byla zvolena open source Common Public License (CPL). \citep{jcode}
\end{description}

\noindent Nìkolik dalších projektù zamìøenıch na podporu CMS Joomla v Eclipse IDE skonèilo ve fázi plánování bez jakéhokoli publikovaného kódu nebo binární distribuce. V souèasnosti tak není dostupné rozšíøení tohoto typu, které by bylo moné nainstalovat do aktuálních verzí Eclipse s podporou pro PHP zaloenou na PDT. Pøitom se zdá, e poptávka po podobném typu nástroje je pomìrnì slušná -- napø. alfa verzi J!Code si i bez specifické podpory pro systém Joomla! stáhlo více ne 8\,000 lidí \citep[viz][]{jcode}.

\chapter{Návrh metodiky vıvoje rozšíøení CMS Joomla v Eclipse IDE}
Vıvoj software\footnote{Zde je myšleno pouze samotnı vıvoj (programování) software, nikoliv fáze analızy a návrhu, které jsou souèástí vıvoje SW v širším slova smyslu.} je iterativní proces, ve kterém se neustále støídá realizace zmìn v kódu a jejich následné testování (a u v prostøedí samotné vyvíjené aplikace, nebo napø. uvnitø jednotkového testu), ze kterého èasto vzejdou poadavky na další zmìny. Nazıvejme tento cyklus, bìnì oznaèovanı jako \uv{Development Workflow}, metodikou vıvoje. Bez kvalitní metodiky nemùe bıt proces vıvoje efektivní. 

Jak však mùeme hodnotit kvalitu metodiky vıvoje SW a jaké jsou její znaky? Dále uvádím nìkolik pøíkladù vlastností, které by dle mého názoru optimální metodika mìla mít:
\begin{itemize}
	\item jednotlivec nebo tım je s metodikou identifikován, nemá problémy s vyuíváním nástrojù èi postupù a ve vìtšinì pøípadù tak dokáe èinit efektivnì,
	\item jednotlivé nástroje jsou vyuívány zpùsobem, ke kterému byly navreny,
	\item je minimalizováno mnoství \uv{servisních} úkonù, které nemají pøímı vliv na vısledek práce èi pùsobí pøímo rušivì\footnote{Pøíkladem rušivého servisního úkonu pøi vıvoji Java aplikací je nutnost restartování aplikace pro promítnutí zmìny v kódu (kromì zmìny tìla metody). Pøíkladem z vıvoje rozšíøení Joomly mùe bıt synchronizace kódu v projektu s kódem v CMS, pokud ji musí uivatel iniciovat.},
	\item všechny nástroje a postupy jsou vzájemnì kompatibilní, nepøekrıvají se a nenechávají mezi sebou velké mnoství \uv{hluchého prostoru}.
\end{itemize}

\noindent Optimální metodika je samozøejmì teoretická konstrukce. Pøi praktickém vıvoji bìnì dochází k ohıbání nástrojù daleko za hranice pøedstavivosti jejich autorù, na nekompatibilitu narazíme i mezi jednotlivımi èástmi IDE a s rostoucí komplexností aplikace dochází ke zvyšování poètu servisních úkonù, nebo nárùstu jejich rušivıch vlivù\footnote{Vrátíme-li se k pøíkladu Javové aplikace, pak s nárùstem její komplexnosti typicky dochází také k nárùstu èasu potøebného k jejímu restartování.}. V praxi je tedy metodika vıvoje vısledkem mnoha kompromisù. Klíè k efektivní práci pak leí ve schopnosti správnì se rozhodnout, kde ustoupit a kde naopak nepovolit.

IDE nejsou pøíliš flexibilními nástroji -- ba právì naopak. Monosti jejich uivatelského pøizpùsobení pro práci, pro kterou nebyly navreny, jsou vìtšinou minimální. Na druhou stranu však umoòují øadu standardních úloh øešit velmi efektivnì. Umoòují toti vtìlit metodiku do nástroje. Je-li tato vtìlená metodika pro danı úkol vhodná a zároveò je-li v IDE vhodnım zpùsobem integrována, pøináší koncovım uivatelùm velké úspory èasu, kterı by jinak museli trávit vymıšlením správnıch postupù a konfigurací flexibilnìjších nástrojù.

\section{Doporuèené postupy práce}
Základním pøedpokladem pro vıvoj rozšíøení CMS Joomla je pøipravené testovací prostøedí sestávající typicky z webového serveru Apache s PHP interpretrem a relaèní databáze MySQL. Testovací prostøedí je tedy totoné jako v pøípadì vıvoje \uv{bìnıch} aplikací na platformì PHP a dá se pøedpokládat, e vìtšina potenciálních Joomla vıvojáøù má ji takové prostøedí k dispozici. Dalším nutnım pøedpokladem je funkèní instalace systému Joomla pro testování vyvíjeného rozšíøení nasazená na testovacím prostøedí. Konkrétní nástroje a postupy práce uplatòované ve vıvojovém cyklu se však budou u rùznıch vıvojáøù znaènì rozcházet. Pokusme se nyní analyzovat dvì konkrétní metodiky práce doporuèené dvìma zdroji, které bychom mohli v oblasti vıvoje rozšíøení systému Joomla oznaèit za autoritativní.

\subsection{Sandbox rozšíøení}
Tento postup je doporuèován v knize Matering Joomla! 1.5 \citep{mastering-joomla}. Pøed vıvojem samotného rozšíøení si vytvoøíme základní manifest komponenty (nebo jiného typu rozšíøení) obsahující pouze základní metadata (\uv{Component Sandbox}). V pøípadì komponenty by mezi metadaty mìl bıt napøíklad i název menu v administraèní èásti. Z metadat naopak vynecháme všechny informace vyadující dodateèné soubory (jako instalaèní a odinstalaèní skripty, vypsání souborù tvoøících rozšíøení a podobnì), protoe ty na zaèátku vıvoje ještì neexistují. Samotnı manifest rozšíøení pak zabalíme a nainstalujeme pøes správce rozšíøení Joomla. Pøi instalaci Joomla vytvoøí adresáøe pro rozšíøení na správnıch místech (adresáøe zùstanou v tuto chvíli prázdné) a zaregistruje dané rozšíøení ve své databázi. Vıvoj a testování pak probíhá vytvoøením a úpravou souborù rozšíøení v tìchto adresáøích pøímo v souborovém stromu CMS. Tato technika vyuívá faktu, e k úspìšné instalaci rozšíøení není zapotøebí nic ne samotnı manifest daného rozšíøení\footnote{V pøípadì modulu a pluginu je situace o nìco sloitìjší ne je tomu u komponenty. Kvùli pomìrnì nelogické struktuøe metadat u tìchto typù rozšíøení je u minimálního manifestu nutné uvést alespoò jeden PHP soubor. Jedná se však jen o menší komplikaci, nebo k manifestu staèí pøibalit prázdnı PHP skript.}.

Hlavním nedostatkem této metodiky vıvoje je vıvoj pøímo v souborovém stromu CMS, jeho problémovost byla diskutována ji v oddíle \ref{subsect:cms-summary-and-comparison}. Uveïme nìkteré ze zøejmıch nevıhod tohoto pøístupu:

\begin{itemize}
	\item Logicky související soubory patøící k jednomu rozšíøení jsou v souborovém systému CMS na rùznıch místech. Rozloení souborù tak odpovídá pohledu CMS (soubory rùznıch typù mají rùzné umístìní), spíše ne pohledu vıvojáøe (všechny soubory patøí k jednomu rozšíøení, které právì vyvíjím).
	
	\item Rozloení souborù jednoho rozšíøení v nìkolika adresáøích CMS vede k problémùm pøi pouití systému pro správu verzí. Pro jeho efektivní vyuití musí bıt související soubory pøítomné ve spoleèném adresáøi -- v pøípadì Joomla komponenty je nejbliším spoleènım adresáøem hlavní adresáø CMS a pouití systému pro správu verzí na celé CMS namísto na konkrétní rozšíøení je pøinejmenším problematické.
	
	\item Další problém vzniká pøi pøípravì instalaèního balíèku rozšíøení, kdy je potøeba jednotlivé soubory posbírat z rùznıch umístìní v CMS, nakopírovat je do struktury odpovídající instalaènímu balíèku a vytvoøit èi upravit XML manifest rozšíøení. Pøi pøípravì nové verze instalaèního balíèku je potøeba tento proces zopakovat. Skriptováním nebo vyuitím speciálních nástrojù (napø. Phing, viz \ref{subsect:phing}) lze tento proces zautomatizovat, ale to vyaduje dodateèné znalosti a vynaloené úsilí.
\end{itemize}

\subsection{Synchronizace souborù v CMS pomocí nástroje Phing}
Tento postup je zevrubnì popsán v on-line vıvojáøské dokumentaci CMS Joomla \citep{joomla-extensiondev}. Na rozdíl od techniky sandbox rozšíøení, která nepøedpokládala vyuití konkrétního editoru, IDE nebo jinıch nástrojù, je navíc zamìøen konkrétnì na vyuití Eclipse IDE a nástroje Phing.

Soubory rozšíøení jsou dreny oddìlenì od CMS v rámci samostatného projektu v Eclipse IDE. Struktura projektu navíc mùe odpovídat struktuøe instalaèního balíèku rozšíøení. Nainstalování rozšíøení tak je moné skrz správce rozšíøení buï pøímo z adresáøe projektu, nebo z instalaèního balíèku vytvoøeného prostım zabalením vybranıch souborù projektu. A zde pøichází první uplatnìní pro nástroj k automatizaci sestavení -- Phing. V konfiguraci nástroje (XML soubor) vytvoøíme jednoduchı úkol (Phing task) pro pøípravu instalaèního balíèku, kterı vezme potøebné soubory a vytvoøí z nich archiv.

Pro další práci po nainstalování je nezbytné aktualizovat soubory v souborovém stromu CMS, pokud dojde k jejich zmìnì v projektu. A zde pøichází druhı, zøejmì dùleitìjší úkol pro Phing. V~jeho konfiguraci vytvoøíme další úkol, v rámci kterého budeme chtít kopírovat soubory z projektu do odpovídajících umístìní v souborovém stromu CMS. Pro efektivní práci je pak tøeba zajistit, e se danı úkol spustí pøi kadé zmìnì nìkterého ze souborù v projektu. V Eclipse IDE toho lze docílit pøípravou konfigurace pro spuštìní externího nástroje a zapojení jeho spuštìní pøi kadém automatickém sestavení (automatic build). Pak staèí mít pro danı projekt automatické sestavení zapnuté a Eclipse pøi kadé zmìnì souboru spustí Phing s danım úkolem.

Tento pøístup netrpí ádnım z problémù popsanıch v pøípadì sandbox rozšíøení. Na druhou stranu bychom i zde nalezli prostor ke zlepšení, kterı lze zaplnit implementací specifické podpory pro vıvoj rozšíøení Joomly v Eclipse IDE:

\begin{itemize}
	\item Prvním zøejmım problémem je nároènost pøípravy vıvojového prostøedí \citep[viz][]{joomla-extensiondev}.
	
	\item Samotná konfigurace Phingu v sobì skrıvá problém v podobì duplikace metadat. Cílové umístìní souboru v souborovém stromu CMS Joomla je dáno druhem a názvem rozšíøení a typem souboru. Všechny tyto informace jsou ji obsaeny v XML manifestu rozšíøení. Pøi zmìnì nìkterého z parametrù manifestu majícího vliv na cílové umístìní souboru je pak nutné upravit i konfiguraci pro Phing. Zbyteènì tak vzniká další prostor pro chybu.
	
	\item Proces synchronizace souborù je také pomìrnì neefektivní. Pøi kadé zmìnì jakéhokoli souboru v projektu je spuštìn externí proces, kterı nejdøíve musí naèíst konfiguraèní soubor a pak provést synchronizaci všech souborù rozšíøení, namísto pouze tìch zmìnìnıch\footnote{Phing mùe pøi synchronizaci ignorovat soubory, je se podle èasového razítka nezmìnily. Kontrolu data poslední zmìny však musí provést u všech, nebo se k nìmu ji nedostane informace o tom, které soubory v projektu se zmìnily.}. Tato neefektivita mùe a nemusí bıt problém v závislosti na velikosti projektu a parametrech hardwaru.
\end{itemize}

\section{Metodika vıvoje rozšíøení Joomla CMS s pøímou podporou v Eclipse IDE}
Vıše popsané postupy práce jsou limitovány schopnostmi v souèasné dobì dostupnıch nástrojù. I kdy zejména kombinace nástroje Phing a Eclipse IDE pøináší solidní vıvojáøské workflow, nutnost dodateèné konfigurace (kde navíc dochází k duplikaci metadat) a manuální integrace Phingu v Eclipse zuuje okruh potenciálních uivatelù. Vıvojem specifického rozšíøení pro Eclipse IDE mùeme dosáhnout ještì lepší podpory vıvojáøe, která bude zároveò mnohem pøístupnìjší bìnému uivateli.

\subsection{Návrh základního workflow}
Soustøeïme se nejdøíve na návrh základního workflow pro vıvoj rozšíøení Joomla CMS, tj. procesu od zaloení nového projektu pøes iterativní vıvoj a po tvorbu instalaèního balíèku. Bude nás zajímat pouze nezbytná funkcionalita umoòující efektivní vıvoj v Eclipse IDE relativnì zkušenému Joomla vıvojáøi (tj. vıvojáøi schopnému vyvinout dané rozšíøení i bez podpory IDE, i kdy pravdìpodobnì ménì efektivnì). V další èásti se pak zamìøíme na další moná vylepšení. Pro navrhované základní workflow si nejdøíve na základì provedené analızy stanovme základní poadavky:

\begin{enumerate}
	\item Struktura projektu v IDE by mìla odpovídat struktuøe instalaèního balíèku, nikoliv struktuøe po instalaci rozšíøení. Kromì ji diskutovanıch vıhod lze v tomto uspoøádání pøirozenì udrovat XML manifest rozšíøení, kterı odkazuje na jednotlivé soubory rozšíøení tak, jak se vyskytují v instalaèním balíèku. Pokud by struktura projektu instalaènímu balíèku neodpovídala, odkazy na jednotlivé soubory by v daném kontextu nedávaly smysl a jeho prùbìná aktualizace by u vìtšího projektu byla pomìrnì obtíná.
	
	\item V projektu musí fungovat systém automatické nápovìdy (content assist) jak pro kód obsaenı v projektu, tak pro Joomla API. Content assist je zásadní vıhodou IDE oproti nìkterım jednoduchım textovım editorùm zvyšující produktivitu práce jak u zaèínajících, tak u zkušenıch vıvojáøù. Jeho fungování by mìlo bıt zajištìno bez nároèné konfigurace.
	
	\item IDE by mìlo podporovat synchronizaci mezi projektem a soubory nainstalovaného rozšíøení tak, aby pøi zmìnì souboru v IDE bylo ihned moné otestovat provedenou zmìnu v bìící aplikaci. Monost bez dalších akcí èi prodlev testovat zmìnu v PHP aplikaci je zásadní vıhodou oproti kompilovanım jazykùm vyadujícím velmi èasté restarty aplikace pøi netriviálních zmìnách kódu a proto musí bıt v jakémkoli vıvojovém workflow zachována. Synchronizace by mìla fungovat pouze na základì korektního XML manifestu rozšíøení a znalosti instalaèního adresáøe a verze Joomly. Na základì tìchto vstupù je moné jednoznaènì urèit cílové umístìní libovolného souboru rozšíøení. Struktura manifestu rozšíøení je pøitom zkušenému Joomla vıvojáøi známá, protoe manifest je nutnou souèástí kadého instalaèního balíèku.
\end{enumerate}

\noindent Pozastavme se na chvíli u poadavku na funkènost systému automatického doplòování u Joomla API. Ke splnìní tohoto poadavku musí bıt PHP skripty Joomly souèástí tzv. Build Path projektu. Pouze soubory na Build Path jsou toti pro tyto úèely indexovány. Existuje ale více moností pøidání souborù definujících Joomla API na Build Path -- jednotlivé záznamy mohou mít podobu projektu ve workspace, archivu dodávaného spolu se zásuvnım modulem Eclipse, nebo externího archivu èi sloky. Otázkou tedy je, zda má bıt Joomla API radìji souèástí dodávanıch pluginù v Eclipse, nebo má bıt pøilinkováno z instalace Joomly, je je souèástí testovacího prostøedí. I kdy první varianta má zdánlivì jisté vıhody, má také øadu problémù. Prvním z nich jsou moné licenèní problémy, protoe GPL licence pouívaná Joomlou je vıraznì restriktivnìjší ne licence zamıšlená pro vyvíjené rozšíøení Eclipse (EPL). Další nevıhodou je nemonost dodávání všech verzí API vèetnì všech \uv{minor} verzí. Oproti tomu pøi vyuití souborù z vıvojáøovi instalace systému je cílová verze API jasnì dána jeho verzí Joomly. Tato varianta se tak jeví jako vıhodnìjší. Potenciální nevıhodou je, e nutnì potøebujeme znát adresáø Joomly, pokud mono ještì pøed vytvoøením projektu. Znalost koøenového adresáøe Joomly je však nutnım pøedpokladem i pro implementaci synchronizace mezi projektem a nainstalovanım rozšíøením, co rapidnì sniuje vıznam této nevıhody.

\subsubsection{Registrace a správa instalací Joomla CMS v IDE}
Dostáváme se tak k prvnímu kroku, kterı sice není pøímo souèástí procesu vıvoje jednotlivého rozšíøení CMS, ale je nezbytnım pøedpokladem k realizaci podpùrnıch funkcí IDE v tomto procesu. Vıvojáø musí IDE øíci o umístìní koøenového adresáøe Joomly pouívané pøi vıvoji. Dále bude tato \uv{instalace Joomly} nazıvána Joomla server, i kdy technicky se jedná spíše o serverovou aplikaci ne standalone server. Tento název však intuitivnì odpovídá pojetí Joomly jako portálové platformy. Lze oèekávat, e nìkteøí vıvojáøi budou pøi vıvoji a testování vyuívat nìkolik rùznıch verzí Joomly, pøípadnì více instancí stejné verze s rùznou konfigurací. Vıvojáø by tak rozhodnì mìl mít monost zaregistrovat v IDE více rùznıch serverù.

Pøi registraci Joomly je dùleitım aspektem její verze. Rùzné verze mohou vyadovat rùznı formát manifestu rozšíøení, mohou mít rùznı proces instalace a odinstalace rozšíøení a jiné umístìní souborù rozšíøení. Pokud to bude moné, mìlo by IDE provést autodetekci verze Joomly. IDE musí také umonit zmìny v konfiguraci Joomla serverù.

\subsubsection{Zaloení nového projektu}
Pøed rozebráním samotného zaloení projektu je potøeba si poloit jednu otázku -- chceme jít cestou jednoho rozšíøení na jeden projekt, nebo umoníme správu více rozšíøení v rámci jednoho projektu? Obojí je technicky proveditelné, ale otázka je, která cesta je ta správná. Argumentem pro více rozšíøení na jeden projekt by mohlo bıt, e kvùli existenci více specializovanıch typù funkèních rozšíøení (komponenty, pluginy a moduly) je potøeba pro dodání komplexní jednotky funkènosti vytvoøit hned nìkolik rozšíøení, které spolu funkènì blízce souvisí -- mohli bychom tedy chtít tyto související rozšíøení sjednotit v rámci jednoho projektu. Další vıhodou tohoto rozloení projektu je funkènost content completion napøíè všemi obsaenımi rozšíøeními bez další konfigurace. Na druhé stranì argumentem pro jediné rozšíøení na jeden projekt je nezávislost ivotního cyklu jednotlivıch rozšíøení\footnote{Kadé rozšíøení má svùj samostatnı instalaèní balíèek. Od verze Joomla 1.6 je podporovanı i speciální instalaèní balíèek obsahující více klasickıch instalaèních balíèkù a speciální manifest. Tento \uv{multibalíèek} usnadòuje instalaci komplexních rozšíøení administrátorùm. Vıvojáø však dále bude vnímat jednotlivá rozšíøení oddìlenì.} a fakt, e hranice mezi jednotlivımi rozšíøeními jsou silnìjší ne hranice mezi jednotlivımi soubory. Hranice rùznıch projektù by tak mohly bıt ádoucí. Na základì uvedenıch argumentù jsem se nebyl schopen jednoznaènì rozhodnout pro jednu cestu. Proto jsem prozatím zvolil vnitøní podporu pro více rozšíøení na jeden projekt s tím, e systém prozatím vdy vede vıvojáøe k jednomu rozšíøení na jeden projekt. Obì cesty tak zùstávají otevøené a koneènı vıbìr jedné z variant mùe zohlednit praktické zkušenosti a poadavky budoucích uivatelù.

Koneènì se dostáváme k zaloení nového projektu (je bude na základì vıše øeèeného obsahovat právì jedno rozšíøení). Zaloit novı projekt mùeme chtít buï pro zcela nové rozšíøení, nebo pro další vıvoj ji existujícího rozšíøení. V prvním pøípadì budeme v Eclipse IDE hledat vhodného prùvodce pro vytvoøení nového projektu (new project wizard). Ve standardní distribuci Eclipse pro PHP vıvojáøe bychom zøejmì zvolili prùvodce pro zaloení PHP projektu, kterı je nejblíe charakteru námi zakládaného projektu. V tomto prùvodci mùeme nastavit jméno zakládaného projektu, verzi PHP serveru, knihovny na Build Path a podobnì. Prùvodce pro vytvoøení nového projektu pro rozšíøení Joomla CMS by se místo toho mìl primárnì zamìøit na základní údaje o daném rozšíøení -- jeho název, typ a ostatní základní metadata. Na základì tìchto údajù potom mùe doporuèit název projektu, kterı bude moci vıvojáø upravit. Dalším krokem by mìl bıt vıbìr primárního Joomla serveru, proti kterému chceme vyvíjet. Nabídka serverù by mìla obsahovat všechny servery z konfigurace, na které je dané rozšíøení moné nainstalovat. Po ukonèení prùvodce by ve workspace mìl vzniknout projekt obsahující základní manifest rozšíøení, pøípadnì další povinné soubory podle typu rozšíøení. Na Build Path projektu by mìly bıt automaticky pøidány soubory definující API vybraného Joomla serveru, aby byla zajištìna funkènost content completion.

Pokud chceme v IDE zkusit vyvíjet existující rozšíøení, mùeme bıt v jedné ze dvou situací -- buï máme ji ve VCS k dispozici zkonfigurovanı projekt od jednoho z našich spolupracovníkù. V tom pøípadì staèí provést checkout daného projektu (pøípadnì clone v pøípadì DVCS). Pokud ádnı zkonfigurovanı projekt nemáme, nebo byl projekt vytvoøen jako obecnı PHP projekt a my chceme vyuít vıhod specifické podpory pro Joomlu, máme velmi pravdìpodobnì k dispozici alespoò instalaèní balíèek rozšíøení. IDE by pak mìlo nabízet prùvodce pro vytvoøení projektu z instalaèního balíèku. Jeliko se prakticky jedná o import instalaèního balíèku do workspace, spadá danı prùvodce mezi prùvodce importem (import wizards). Kromì standardních instalaèních balíèkù by mìl import wizard podporovat i \uv{multibalíèky} zavedené v Joomle 1.6.

\chapter{Implementace}
\section{Platforma Eclipse}
Eclipse IDE patøí bezesporu k nejrozšíøenìjším vıvojovım prostøedím vùbec. Tradiènì nejvìtší relativní trní podíl má na trhu IDE pro platformu Java. Jako dobrá alternativa se ale prosazuje i pro vıvoj v jinıch jazycích -- zejména C, C++ a PHP. Pod hlavièkou Eclipse se však skrıvá více ne jen nìkolik rùznıch distribucí vıvojového prostøedí. Eclipse je v první øadì open source komunita zamìøená na vıvoj nástrojù pro vıvojáøe. Tato komunita je spravována neziskovou pøíspìvkovou organizací Eclipse Foundation, je odpovídá za nezbytnou infrastrukturu, je správcem vıvojovıch procesù a poskytovatelem právních slueb. Mezi mnoha partnery a pøispìvateli Eclipse Foundation nechybí velké korporace jako IBM, Oracle, SAP nebo Nokia.

Veškerı SW vyvíjenı pod køídly Eclipse Foundation je dostupnı komukoli pod Eclipse Public License (EPL) -- velmi benevolentní licencí umoòující vyuití binárních distribucí i zdrojového kódu (vèetnì jeho úprav) v rámci komerèních aplikací. Zároveò za takové uití nevyaduje platbu ádnıch licenèních poplatkù ani zmìnu licence vısledného díla\footnote{\uv{Nakalivé} open source licence typu GPL sice umoòují vyuití kódu zdarma, ale vısledné dílo musí bıt distribuováno celé pod GPL, tj. vèetnì zdrojovıch kódù a zdarma.}. Dùleitım úkolem Eclipse Foundation pak je zajištìní právní bezproblémovosti jakıchkoli autorskıch dìl v rámci jednotlivıch projektù Eclipse. Kadı projekt darovanı Eclipse Foundation tak musí pøed zveøejnìním v rámci Eclipse projít dùkladnou kontrolou, pøi které je nutné doslova ke kadému souboru dohledat majitele autorskıch práv a zajistit právní souhlas ke zveøejnìní pod EPL. Vısledkem je, e veškerı kód a jiná autorská díla dostupná v rámci projektù Eclipse mohou bıt kımkoli vyuita jako souèást open source i komerèních aplikací bez obav o pøípadné autorské spory. I z tohoto dùvodu staví nad platformou Eclipse velké mnoství komerèních nástrojù pro vıvojáøe -- namátkou zmiòme IBM Rational Application Developer, TIBCO Business Studio nebo Zend Studio pro PHP.

Jádrem open source komunity Eclipse je Eclipse Rich Client Platform (Eclipse RCP)\footnote{I kdy je velké mnoství Eclipse projektù zamìøeno na Eclipse RCP a tedy na tvorbu desktopovıch aplikací, zdaleka to neplatí pro všechny. Jako pøíklad mùeme uvést projekty spadající pod Eclipse RT (Eclipse RunTime) zamìøené na vıvoj webovıch aplikací -- napø. Eclipse Virgo nebo Gemini Web. Pod Eclipse bychom také našli bìhová prostøedí pro SOA aplikace nebo mobilní aplikace. Celkovì je tedy paleta Eclipse projektù velmi pestrá.} -- platforma pro tvorbu desktopovıch aplikací se zamìøením na aplikace na vıvojáøe. Eclipse RCP poskytuje základní funkcionalitu modulární desktopové aplikace jako je knihovna pro tvorbu GUI (SWT), modulární systém (OSGi) nebo systém deklarativního rozšiøování GUI (extension points). Dále definuje základní jednotky GUI jako jsou perspektivy (perspektives), pohledy (views) a editory (editors) a nìkteré bìné subsystémy jako napø. správa uivatelskıch nastavení. Konkrétní distribuce Eclipse IDE se pak sestává z Eclipse RCP, zásuvnıch modulù implementujících obecnou funkcionalitu IDE bez ohledu na cílovou platformu a dalších zásuvnıch modulù implementujících funkcionalitu specifickou pro danou platformu nebo typ vıvoje. Kadou distribuci lze pøitom rozšiøovat o další zásuvné moduly a to jak z ostatních distribucí, tak z jinıch projektù, z nich nìkteré ani nemusejí bıt souèástí Eclipse komunity.

Pro vıvoj v PHP lze vyuít jednu z oficiálních distribucí Eclipse IDE -- Eclipse IDE pro PHP vıvojáøe. Tato distribuce bude tedy cílovou platformou pro nástroje pro podporu vıvoje rozšíøení Joomla CMS vyvíjené v rámci této práce. Podívejme se blíe na hlavní souèásti zmínìné distribuce \citep{pdtpackagedetails}: 
\begin{itemize}
	\item Eclipse RCP, základní platformì nezávislá IDE rozšíøení, nástroje pro podporu vıvoje webovıch aplikací (Web Standard Tools, WST),
	\item sada nástrojù usnadòující vıvoj IDE pro dynamické programovací jazyky (Dynamic Languages Toolkit, DLTK),
	\item specifické nástroje pro podporu vıvoje PHP aplikací (PHP Development Tools, PDT).
\end{itemize}

\noindent Vztah hlavních komponent je nastínìn na obrázku \ref{fig:eclipse-php-ide-components}. Eclipse RCP a obecná funkcionalita IDE je obsaena ve všech oficiálních distribucích Eclipse IDE. WST je základním rozšíøením pøidávajícím podporu pro webové technologie jako HTML, XML, CSS nebo JavaScript a jako takové je obsaeno v mnoha oficiálních distribucích. Podpora pro PHP je zajištìna rozšíøením PDT, které ovšem mnoho pokroèilejší funkcionality jako je automatické doplòování a indexování obsahu souborù zajišuje s pomocí jazykovì nezávislıch nástrojù z projektu DLTK.

\begin{figure}[h]
	\centering
	\resizebox{0.75\textwidth}{!}{\includegraphics{resource/eclipse-php-ide-components.pdf}	}
	\caption{Hlavní komponenty Eclipse IDE pro PHP vıvojáøe} \label{fig:eclipse-php-ide-components}
\end{figure}

Pøi vıvoji rozšíøení jakékoliv modulární aplikace je základní otázkou zpùsob integrace jednotlivıch modulù. V ideálním pøípadì by nainstalovanı modul nemìl pùsobit separovanì od zbytku aplikace, ale naopak by se mìl stát její pøirozenou souèástí. Uivateli aplikace by pak mìlo staèit znát nìkolik málo konceptù pouívanıch napøíè rùznımi moduly. Platforma Eclipse je v tomto ohledu velmi úspìšná -- aèkoliv se bìná instalace Eclipse IDE skládá øádovì ze stovek zásuvnıch modulù\footnote{Instalace Eclipse pouitá pøi vıvoji nástrojù pro Joomlu se skládá z více jak tisícovky zásuvnıch modulù.}, ve vısledku pùsobí velmi integrovanım dojmem\footnote{Integrovanı dojem pøi pouití Eclipse IDE ponìkud kazí èetné inkonzistence v chování u rùznıch rozšíøení. To je dáno rozdílnımi tımy a èasto té rozdílnımi spoleènostmi, které za danımi rozšíøeními stojí. V takto decentralizovaném modelu vıvoje je pak logicky mnohem obtínìjší dosáhnout funkèní konzistence, ne v pøípadì nástrojù vyvíjenıch vıluènì vıvojáøi z jedné firmy.}. Podívejme se nyní na hlavní mechanizmy stojící za modularitou Eclipse RCP.

\subsection{OSGi Service Platform}
Jádrem Eclipse RCP je od verze 3.0 modulární systém pro platformu Java OSGi Service Platform (dále OSGi) -- konkrétnì referenèní implementace Equinox vyvíjená v rámci Eclipse. OSGi je specifikací modulárního systému udrovanou mezinárodním konsorciem OSGi Alliance. Pøed bliším pohledem na OSGi se na chvíli zastavme nad tím co vlastnì modulární systém zajišuje a proè je nepostradatelnou souèástí komplexních Java aplikací. Modulární systém jiné umoòuje:

\begin{description}
	\item[Definice závislostí mezi moduly] Jednotlivı modul typicky neobsahuje veškerı kód, kterı je nezbytnı pro zajištìní jeho funkènosti. Pro mnoho úkolù vyuívá kódu èi slueb z jinıch modulù. To platí i pro standardní Java aplikaci bez modulárního systému, proè tedy explicitnì definovat závislosti mezi moduly? Protoe ve standardní Java aplikaci nelze tyto závislosti vynutit za bìhu. OSGi modul mùe pøistoupit pouze k tøídám definovanım v modulech, na kterıch závisí. Pokud nelze tyto závislosti uspokojit, OSGi modul nebude vùbec spuštìn. Oproti tomu bìnou Java aplikaci lze spustit i pøi nedostupnosti nìkterıch závislostí, co vyvolá vıjimky typu \verb|ClassDefNotFoundError| pøi pokusu o jejich naètení.
	
	\item[Verzování] S definicí závislostí mezi moduly úzce souvisí jejich verzování. Modul typicky závisí na urèité minimální verzi jiného modulu, jeliko pouívá API, je v pøedchozích verzích ještì nebylo dostupné nebo mìlo jiné chování. V OSGi jsou verze souèástí definic závislostí a ádnı modul nemùe bıt spuštìn, pokud nejsou pøítomny všechny povinné závislosti v podporovanıch verzích. S tím souvisí také monost vyuití více rùznıch verzí jednoho modulu (knihovny) v jedné aplikací. Bez modulárního systému je toto v Javì zcela nemoné -- pokud je na classpath více verzí stejné knihovny, nelze s jistotou øíci, ze které verze knihovny bude poadovaná tøída naètena (pùjde vdy o první tøídu daného jména, na kterou zavadìè tøíd pøi hledání narazí). V OSGi má kadı modul svou classpath a rùzné moduly mohou vyuívat rùzné verze stejnıch knihoven, pokud to nevede ke konfliktùm (setkání dvou verzí stejné tøídy na jedné classpath).
	
	\item[ivotní cyklus modulu] V OSGi je moné za bìhu aplikace pøidat novı modul, nebo odebrat modul existující. V klasické Java aplikaci to zpravidla není moné. Obzvláštì odebrání èásti aplikace za bìhu je bez modulárního systému prakticky nemoné\footnote{Vìtšina standardních Java aplikací prochází po startu fází inicializace, ve které dochází ke konfiguraci jednotlivıch subsystémù. V pøípadì dynamické modulární aplikace je však potøeba dùkladnì ošetøovat i fázi ukonèování jednotlivıch modulù, ve které musí bıt uvolnìny všechny pouívané zdroje a musí dojít k ukonèení pouívání modulu zbytkem aplikace. K úplnému odstranìní tøíd obsaenıch v modulu z pamìti je nutné dereferencovat všechny jejich instance v celé aplikaci. Bez striktnì definovaného modelu kolaborace mezi moduly je tak plné odstranìní modulu za bìhu prakticky nemoné.}. I v pøípadì OSGi je však k vyuití této funkcionality potøeba zdret se urèitıch postupù a poèítat s touto moností pøi návrhu jednotlivıch subsystémù aplikace. V Eclipse RCP toto zpravidla moné není. Na druhou stranu se hojnì vyuívá ivotního cyklu pøi aktivaci modulu (viz. dále).
	
	\item[Skrıvání implementace] V Javì existuje øada kontextù pro viditelnost (visibility scopes). Nejvyšším z nich je balíèek pøedstavující jmennı prostor pro jednotlivé tøídy. Jako další pøirozenı kontext bychom zøejmì vybrali JAR archiv -- základní jednotku pro distribuci Java knihoven. JAR archiv však ádnı kontext pro omezení viditelnosti nepøedstavuje. Za bìhu aplikace dochází k setøení hranic mezi JARy a pøíslušnost k JARu je u jednotlivıch tøíd naprosto podøadná ve srovnání s pøíslušností k balíèku. OSGi moduly oproti standardním JARùm umoòují ponechat nìkteré balíèky jako privátní a oddìlit tak API modulu od jeho implementace, která mùe zùstat ostatním modulùm skrytá.
	
	\item[Instalace a aktualizace] Pøi instalaci novıch modulù je nutné doinstalovat i veškeré jejich závislosti, které zatím nejsou nainstalovány. Zároveò je nutné zajistit, e instalované moduly jsou kompatibilní s verzemi všech ji pøítomnıch modulù. V pøípadì Eclipse se tak pøi instalaci znovu vyuívají OSGi metadata jednotlivıch modulù, které jsou nutné i pro jejich spuštìní. Správa závislostí samozøejmì není pouze doménou modulárních systémù. Pro bìné Java aplikace lze pro správu závislostí vyuít napøíklad nástroje Maven nebo Ivy. Kadı má svùj formát metadat a umoòuje k vybrané knihovnì stáhnout všechny její tranzitivní závislosti. Za bìhu však tyto závislosti nejsou ádnım zpùsobem vynuceny a èasto dochází ke konfliktùm. Naproti tomu instalace nového zásuvného modulu do Eclipse zpravidla nezpùsobí ádné konflikty mezi moduly tvoøícími aplikaci.
\end{description}

\subsubsection{OSGi bundle a jeho ivotní cyklus}
Jednotkou modularity v OSGi je bundle. Základní bundle\footnote{Vedle základních bundlù podporuje OSGi framework s OSGi Web Containerem i WAR archivy.} je bìnı JAR archiv, kterı v manifestu obsahuje OSGi metadata (hlavièky JAR manifestu). Jedinou vyadovanou hlavièkou je \verb|Bundle-SymbolicName| pøedstavující identifikátor bundlu. Vìtšina bundlù však ke své èinnosti vyaduje jiné bundly a proto musí explicitnì uvést své závislosti. Bez explicitních definic závislostí má zavadìè tøíd pøístup pouze ke tøídám definovanım v rámci bundlu a ke tøídám ze základní knihovny. \citep{osgi-spec-core}

\lstinputlisting[caption={Pøíklad manifestu jednoduchého OSGi bundlu}, label=lst:sample-osgi-bundle]{listings/sample-bundle-manifest.txt}

Ukázkovı OSGi bundle manifest na vıpisu \ref{lst:sample-osgi-bundle} demonstruje nìkteré základní vlastnosti OSGi. Podívejme se teï na vıznam nìkterıch hlavièek:

\begin{description}
	\item[Export-Package] Základní jednotkou závislosti mezi bundly je Java balíèek. Tato hlavièka obsahuje seznam balíèkù obsaenıch v daném bundlu, které jsou k dispozici ostatním bundlùm. Všechny ostatní balíèky neuvedené mezi exportovanımi balíèky jsou privátní a tøídy v nich obsaené nejsou standardnì dostupné z ostatních bundlù.  Exportované balíèky tak pøedstavují API bundlu.
	
	\item[Import-Package] Pokud chceme v nìkterém bundlu vyuívat tøídy definované v jinıch bundlech, musí bıt jejich balíèky z danıch bundlù exportovány a my je pak obratem musíme importovat. Pøi importu se bere v úvahu mnoství dodateènıch omezení -- jedním ze základních je poadavek na kompatibilitu verze balíèku.
	
	\item[Require-Bundle] Pøedstavuje zkratku pro import všech balíèkù exportovanıch z daného bundlu. V rámci Eclipse je naprostá vìtšina závislostí øešena pomocí této hlavièky, i kdy OSGi komunita jednoznaènì doporuèuje vyuívání pøesnìjší \verb|Import-Package|. Importování jednotlivıch balíèkù je v praxi tìko pouitelné bez automatizace tvorby manifestu, protoe bìnı Eclipse bundle pouívá øádovì stovky \uv{cizích} balíèkù. Nástroje dodávané pro tvorbu zásuvnıch modulù pro Eclipse jsou však zamìøeny na manuální tvorbu manifestu a tak definice závislostí pøes \verb|Require-Bundle| je prakticky jedinou schùdnou cestou.
	
	\item[Bundle-Activator] Tøída implementující rozhraní \verb|org.osgi.framework.BundleActivator| slouící k øízení ivotního cyklu a interakci s OSGi frameworkem (viz. dále).
\end{description}

\noindent Bundly je moné pouívat uvnitø OSGi kontejneru\footnote{Nìkteré bundly vùbec nevyuívají OSGi API nebo sluby a proto jsou plnohodnotnì funkèní i mimo OSGi kontejner. Jiné mohou nabízet mimo kontejner alespoò omezenou funkcionalitu.}. Existuje mnoho implementací kontejnerù s rùznım zamìøením od mobilních systémù po aplikaèní servery. Eclipse RCP vyuívá vlastní implementaci Equinox rozvíjenou v rámci projektu Eclipse RT. Samotnı OSGi kontejner je velmi kompaktní -- typicky se vejde do jednoho JARu. Lze ho spustit jak v klasické Java aplikaci, tak v rámci webové aplikace nasazené uvnitø servlet kontejneru. V jednom virtuálním stroji mùe najednou bìet více OSGi kontejnerù vèetnì moného zanoøení jednoho do druhého\footnote{Jedním z pøíkladù takového zanoøení je vytvoøení OSGi kontejneru aplikací bìící uvnitø J2EE serveru. Vìtšina moderních aplikaèních serverù toti internì vyuívá právì OSGi.}.

Pøi pouití prochází bundly v OSGi kontejneru ivotním cyklem nastínìnım na obrázku \ref{fig:osgi-bundle-lifecycle}. Ten zaèíná instalací bundlu do kontejneru. Ne je moné z bundlu naèítat a spouštìt jakékoliv tøídy, musí kontejner vypoèítat všechny jeho závislosti vzhledem k deklarovanım poadavkùm a ostatním bundlùm nainstalovanım v kontejneru (resolution process). Pokud se podaøí všechny závislosti uspokojit, pøechází bundle do stavu \verb|resolved|. Od této chvíle ji je moné z nìj naèítat tøídy a pokud se jedná o \uv{knihovní} bundle, je ji plnì funkèní. 

Základní model kooperace mezi bundly však není zaloen na pøímém pouití typù deklarovanıch v rámci bundlu (to by odporovalo základním poadavkùm na modulární design -- vysoká koherence v rámci modulu a nízká provázanost jednotlivıch modulù). Korektní bundly by mìli primárnì kooperovat pomocí OSGi slueb. Ty budou podrobnìji rozebrány v následující sekci. Prozatím si mùeme slubu pøestavit jako objekt nabízející pøístup k urèité funkènosti bundlu, kterı slubu poskytuje. Korektní bundle by mìl poskytovat sluby ostatním bundlùm pouze v pøípadì, e je aktivní (tj. nachází se ve stavu \verb|active|). Pøi aktivaci bundlu je volána metoda \verb|start()| jeho aktivátoru, pokud má nìjakı zaregistrovanı. Zároveò mohou na aktivaci bundlu poslouchat nìkteré \uv{servisní bundly} které mohou provést registraci slueb za nìj na základì obsaenıch metadat. Pøi deaktivaci bundlu, kdy dochází k pøechodu ze stavu \verb|active| do stavu \verb|resolved| pøièem je volána metoda \verb|stop()| aktivátoru, jsou sluby deaktivovaného bundlu automaticky odregistrovány.

\begin{figure}[h]
	\centering
	\def\svgwidth{0.75\textwidth}
	\input{resource/osgi-bundle-lifecycle.pdf_tex}
	\caption{ivotní cyklus OSGi bundlu. Zdroj: \citep{wiki-osgi}} \label{fig:osgi-bundle-lifecycle}
\end{figure}

\noindent Kdy pøesnì dochází k aktivaci bundlù závisí do znaèné míry na konkrétním nasazení OSGi. V pøípadì serverové aplikace je zøejmì vıhodné aktivovat všechny bundly automaticky ihned poté, co pøejdou do stavu \verb|resolved|, co umoní celkovou inicializaci aplikace (s vèasnım odhalením pøípadnıch chyb), která je tak pøipravena obsluhovat poadavky klientù bez dalších prodlev zpùsobenıch odloenou inicializací. Delší doba startu serverové aplikace je ve vìtšinì pøípadù pøijatelná. Naproti tomu u desktopové aplikace je doba startu jedním z kritickıch faktorù ovlivòující produktivitu koncového uivatele. Eclipse RCP proto v maximální míøe vyuívá odloení inicializace do doby prvního pouití. Na úrovni OSGi bundlù je odloená inicializace realizovatelná pomocí nastavení hlavièky \verb|Bundle-ActivationPolicy| na \verb|lazy|. Bundle s tímto nastavením je pøechází po uspokojení závislostí automaticky do stavu \verb|starting|, ve kterém zùstává do prvního úspìšného naètení jakékoliv v nìm obsaené tøídy. V momentì naètení první tøídy pokraèuje aktivace standardním zpùsobem (zavolání aktivátoru a notifikace ostatních bundlù).

Aktivované bundly mohou bıt deaktivovány a následnì odinstalovány z kontejneru. Pro úplné odstranìní tøíd odinstalovaného bundlu z pamìti je nutné deaktivovat všechny bundly importující nìkterı z jeho balíèkù a znovu se pokusit uspokojit jejich závislosti. Celı proces je pomìrnì sloitı a pøi nevhodném návrhu systému mùe snaha o odstranìní jednoho bundlu vést kvùli vzájemnım vazbám k praktickému restartu aplikace. V Eclipse se však odstraòování bundlù za bìhu nebo jejich dynamická aktualizace prakticky nepouívá a tak se jím nebudeme dále zabıvat.

V souvislosti s Eclipse IDE je tøeba upozornit, e instalace OSGi bundlu do kontejneru je odlišnı koncept od instalace novıch rozšíøení Eclipse. Pøí instalaci rozšíøení dochází k jejich staení a pøidání do bìhového profilu. Instalace rozšíøení je navíc zpravidla iniciována uivatelem. Oproti tomu operace ivotního cyklu bundlù jsou spravovány automaticky a dochází k nim pøi kadém bìhu Eclipse. Po startu aplikace je nejdøíve spuštìn OSGi kontejner a následnì jsou do nìj podle nastavení v profilu instalovány jednotlivé bundly. Ty jsou pak postupnì aktivovány podle toho, které funkce aplikace uivatel vyuívá.

\subsubsection{OSGi sluby}
Importované balíèky pøestavují statické závislosti bundlù. V momentì, kdy bundle pøejde do stavu \verb|resolved|, je nelze zmìnit jinak ne pøenesením do stavu \verb|installed| a zopakováním navázání závislostí. Z pohledu bundlu tento proces pøedstavuje efektivní restart, bìhem kterého bundle ztrácí jakıkoliv nepersistentní stav, protoe je bìhem nìj vytvoøen novı zavadìè tøíd\footnote{Identita tøídy je v Javì daná kombinací kvalifikovaného názvu a zavadìèe, kterı jí naèetl. Stejná tøída (podle názvu) tak mùe existovat ve virtuálním stroji nìkolikrát, pokud jsou její jednotlivé verze naèteny rùznımi zavadìèi. Tyto tøídy jsou však vzájemnì nekompatibilní a kadá má vlastní sadu statickıch polí.}. Samy o sobì proto závislosti mezi balíèky nepøedstavují dobrı základ pro modulární systém se slabou vazbou mezi moduly.

Dostáváme se tak k druhému druhu závislostí mezi bundly -- OSGi slubám. Sluby pøedstavují dynamické závislosti, které se mohou bìhem bìhu aplikace objevovat a znovu mizet. Slubou mùe bıt jakıkoliv objekt. Aby byla sluba dostupná ostatním, musí bıt zaregistrována v registru slueb. Pøi registraci je nutné uvést rozhraní sluby (rozhraním sluby mùe bıt buï pøímo typ sluby, nebo kterıkoliv jeho rodiè èi implementované Java rozhraní) a volitelnì další metadata. Registrace probíhá typicky pøi aktivaci modulu, i kdy u øady slueb je vhodná registrace v libovolném èase po aktivaci v návaznosti na nìjakou vnìjší událost -- napøíklad sluba reprezentující komunikaèní kanál s externím zaøízením by zøejmì mìla bıt zaregistrována pøi pøipojení daného zaøízení k poèítaèi. Stejnì tak by mìla bıt pøi jeho odpojení odregistrována. Zájemci o vyuití slueb je mohou vyhledávat v registru podle jejich rozhraní a dodateènıch metadat.

Dynamickı charakter slueb klade vysoké nároky na jejich uivatele. První problém souvisí s inicializací bundlù -- i kdy je v OSGi nìkolik nástrojù umoòujících více èi ménì kontrolovat poøadí aktivace bundlù, v robustním modulárním systému by se na toto poøadí nemìlo spoléhat. Bundle vyuívající slueb ostatních bundlù pak ale musí poèítat s tím, e v dobì jeho aktivace nìkteré z nich ještì nejsou zaregistrovány. Mìl by se tedy zapsat jako posluchaè na registraci chybìjících slueb a dokonèit inicializaci v dobì, kdy jsou ji všechny k dispozici. Druhı problém souvisí s faktem, e sluba mùe bıt kdykoliv odregistrována (vzpomeòme na slubu pro komunikaci s externím zaøízením odregistrovanou pøi jeho odpojení). Korektní bundle by odregistrovanou slubu mìl okamitì pøestat pouívat a to vèetnì zrušení pøípadnıch silnıch referencí, aby byla sluba uvolnìna pro garbage collection. Aktivní správa slueb pomocí nízkoúrovòovıch OSGi API je velmi nároèná -- vyaduje velké mnoství opakujícího se kódu. Pro praktické pouívání je proto zpravidla potøeba vyuít nìkteré nadstavby nad jádrem OSGi. Dále si pøedstavíme jednu takovou nadstavbu.

\subsubsection{Declarative Services}
Declarative Services je sadou OSGi slueb specifikovanıch v rámci Service Compendium specifikace \citep{osgi-spec-compendium}, jejich úkolem je zjednodušení tvorby a pouívání OSGi slueb. Základním konceptem Declarative Services je komponenta (Component). Komponentou mùe bıt libovolná tøída s bezparametrickım konstruktorem obsaená v bundlu. Kadá komponenta má svou XML konfiguraci, ve které je uvedeno jaké OSGi sluby nabízí a jaké vyaduje. Implementace Declarative Services pak funguje jako Inversion of Control kontejner\footnote{Pokud nejste seznámeni s termíny Dependency Injection nebo Inversion of Control, mùete jejich vysvìtlení nalézt napøíklad na webu Martina Fowlera \url{http://martinfowler.com/articles/injection.html}.} starající se o ivotní cyklus komponent v závislosti na stavu bundlu a dostupnosti slueb, na nich komponenta závisí. Nejsnáze lze Declarative Services vysvìtlit na pøíkladu.

\lstinputlisting[language=XML, caption={Pøíklad konfigurace Declarative Services}, label=lst:osgi-ds-server-manager]{listings/joomla-server-manager.xml}

Vıpis \ref{lst:osgi-ds-server-manager} obsahuje mírnì upravenou konfiguraci jedné z komponent vyvinutıch v rámci diplomové práce. Pro pøehlednost byla zkráceny názvy balíèkù. Element \verb|implementation| obsahuje kvalifikovanı název implementaèní tøídy komponenty. V elementu \verb|service| je uvedeno, e tato komponenta poskytuje jednu OSGi slubu s rozhraním \verb|IJoomlaServerManager|. Element \verb|reference| udává, e komponenta ke své èinnosti vyaduje OSGi slubu typu \verb|IJoomlaDeployer|. Tato sluba se má do instance komponenty vloit pomocí metody \verb|setDeployer| a v pøípadì zrušení její registrace se komponenta upozorní zavoláním metody \verb|unsetDeployer|. Sluba je nezbytná pro fungování komponenty (\verb|cardinality| je \verb|1..1|) a tak v pøípadì její nedostupnosti dojde k deaktivaci komponenty a odregistrování všech OSGi slueb, které nabízí (v tomto pøípadì bude automaticky odregistrována sluba \verb|IJoomlaServerManager|). Pro vysvìtlení dalších nastavení a konceptù viz \citep{osgi-spec-compendium}.

Declarative Services sledují aktivace bundlù obsahujících konfigurace komponent. Pokud jsou k dispozici všechny sluby, na nich daná komponenta závisí, jsou reference na tyto sluby vloeny do komponenty a ta je následnì aktivována \footnote{Komponenty nabízející OSGi sluby mohou bıt také instancovány a aktivovány a v momentì, kdy nìkdo tuto slubu zaène pouívat. Registraci v registru slueb mohou Declarative Services provést i kdy sluba ještì nebyla instancována pouze na základì uspokojení jejích závislostí.}. Registraci OSGi slueb nabízenıch komponentou provádí za bundle Declarative Services, stejnì jako jejich odregistrování v pøípadì, e závislosti komponenty ji dále nelze uspokojit.

\subsection{Body rozšíøení}
Jak ji bylo zmínìno, jedním z hlavních pøedpokladù úspìchu v pøípadì modulárního systému je slabá vazba mezi jednotlivımi moduly. Jednou z moností realizace této vazby jsou OSGi sluby. Ty je moné vyuít zejména jako API jednotlivıch modulù (bundlù). Nejsou ale pøíliš vhodné k rozšiøování grafického uivatelského rozhraní. K tomuto úèelu je na platformì Eclipse RCP vyuíván systém bodù rozšíøení (extension points). Rùzné aspekty tohoto systému si vysvìtlíme na jednoduchém pøíkladì.

Øeknìme e chceme pøidat novou poloku do menu Eclipse IDE. Z funkèního hlediska je nejdùleitìjší èástí poloky menu kód, kterı se spustí po jejím vybrání. Pro uivatele je ale zøejmì zásadní její prezentace v menu, tedy popisek a pøípadnì ikona. Zatímco obsluha vıbìru poloky musí bıt v naprosté vìtšinì pøípadù provádìna programovì, k jejímu vykreslení staèí pouze deklarativní popis. Obsluhující tøídu tak potøebujeme a v momentì, kdy uivatel na danou poloku v menu klikne, co umoòuje oddálit její inicializaci a do doby prvního pouití.

Eclipse plugin\footnote{Všechny zásuvné moduly Eclipse jsou OSGi bundly. V Eclipse komunitì se ale zpravidla nazıvají \uv{plugins}.} starající se o vykreslování a správu poloek menu obsahuje definici bodu rozšíøení pro pøidávání novıch poloek. Definice má formu XML schématu rozšíøeného o další metadata vyadovaná vizuálním editorem pro rozšíøení. Pluginy je chtìjí pøidat poloku do menu tak uèiní vloením odpovídající XML struktury do plugin manifestu\footnote{Plugin manifest je XML soubor obsaenı v koøenovém adresáøi pluginu se standardním názvem \verb|plugin.xml|. Nejedná se tedy o JAR manifest -- ten se nachází na standardní cestì \verb|META-INF/MANIFEST.MF|. Kadı Eclipse plugin musí mít JAR manifest s OSGi metadaty, protoe kadı plugin je OSGi bundlem. Plugin manifest mají jen pluginy deklarující body rozšíøení nebo pøispívající do bodù rozšíøení. Pùvodnì slouil plugin manifest i pro definici závislostí mezi pluginy. Tato jeho role ovšem skonèila s pøechodem na OSGi ve verzi Eclipse 3.0.}. V našem ilustraèním pøíkladì by schéma vyadovalo uvést minimálnì název poloky, kvalifikovanı název tøídy pro obsluhu vıbìru poloky a volitelnì cestu k ikonì. V praxi je schéma podobného bodu rozšíøení komplexnìjší -- je napøíklad potøeba identifikovat menu, do kterého chceme poloku pøidat (kromì hlavního menu existují rùzná kontextová menu a podobnì), a její pozici v menu. Dále je potøeba kontrolovat, zda je poloka viditelná a aktivní. Pro tento úèel je moné deklarativnì definovat rùzné vırazy, které jsou pak pøi zobrazení menu vyhodnocovány. Vše proto, aby se oddálila inicializace pluginù a do doby, kdy jsou poprvé vyuity.

Shròme si zpùsob fungování bodù rozšíøení. Plugin nabízející bod rozšíøení musí definovat jeho schéma. Za bìhu pak mùe pomocí speciálního API (extension registry) procházet pøíspìvky ostatních pluginù do tohoto bodu rozšíøení (extension contributions). Extension registry pro zjištìní jednotlivıch pøíspìvkù musí z kadého pluginu naèíst pouze jeden konfiguraèní soubor (plugin manifest). Pøitom bere v úvahu všechny pluginy ve stavu \verb|resolved| -- tj. i dosud neaktivní pluginy, které ještì neprošly inicializací. Plugin deklarující bod rozšíøení pak podle informací obsaenıch v jednotlivıch pøíspìvcích napø. vykreslí poloku v menu, zobrazí nové view, nebo provede nìjakou jinou akci. Instancování pøípadnıch tøíd vyadovanıch bodem rozšíøení by pøitom mìl maximálnì oddálit.

\subsection{Eclipse Modeling Framework}
Datovı model je centrálním bodem mnoha aplikací. V Eclipse IDE najdeme velké mnoství rùznıch datovıch modelù. Vzhledem k modulárnosti Eclipse èasto nejsou tyto modely vzájemnì propojené. Na rozdíl od podnikovıch aplikací toti Eclipse nemá nìjaké centrální uloištì dat typu relaèní databáze. I kdy nìkolik málo projektù mùe relaèní databázi vyuívat\footnote{Napøíklad DLTK vyuívá relaèní databáze HSQLDB k ukládání indexù skriptù.}, vìtšina pluginù si svá data ukládá ve formì souborù obsahujících XML, serializované Java objekty nebo textová data v nìjakém proprietárním formátu. Reprezentace dat v pamìti je u jednotlivıch datovıch modelù také do znaèné míry odlišná. Tato rùznorodost samozøejmì vedla ke znaèné duplikaci, kdy bìné operace s modelem, které by mohli bıt implementovány genericky a fungovat s libovolnım konkrétním modelem, jsou implementovány pro kadı model zvláš a pokadé jinak. To mimo jiné klade dodateènou zátì na vıvojáøe, kterı se pøi pøechodu k novému projektu musí seznamovat s jeho specifickou implementací datového modelu.

Tento problém se kromì jiného snaí øešit Eclipse Modeling Framework (EMF). EMF se snaí o pøeklenutí svìta SW modelování (soustøedìného kolem Object Management Group a jejích standardù, pøedevším UML) a svìta èistého programování. Vıvojáøi EMF ho nazıvají \uv{pragmatickım pøístupem k modelování} \citep{emf-bible}. V jádru EMF stojí Ecore -- meta model slouící k popisu datovıch modelù. Ecore model si v zásadì mùeme pøedstavit jako UML class diagram bez nìkterıch vlastností které se nedají pøímo namapovat na koncepty Javy (napø. asociace musí bıt striktnì binární, protoe asociace s vyšší aritou se nedá v Javì pøímo vyjádøit). V tìsném svázání modelu s implementací se právì projevuje pragmatickı pøístup EMF oproti UML. Pøes urèité odlišnosti je Ecore model UML class diagramu velmi podobnı a s urèitou ztrátou informací je moné z jednoho vygenerovat druhı a naopak. UML však není jediná reprezentace datového modelu, která mùe slouit jako zdroj pro Ecore model nebo mùe bıt z Ecore modelu vytvoøena. Další takovou reprezentací je XML schéma a poslední ale zøejmì nejdùleitìjší jsou tøídy a rozhraní v Javì. Vztah uvedenıch technologií zachycuje obrázek \ref{fig:ecore-uml-xsd-java}.

\begin{figure}[h]
	\centering
	\includegraphics{resource/ecore-uml-xsd-java.pdf}	
	\caption{Ecore spojuje Javu, XML a UML. Pøevzato z: \citep[][p. 31]{emf-bible}} \label{fig:ecore-uml-xsd-java}
\end{figure}

\noindent Uveïme nìkteré pøípady uití EMF plynoucí z pøevoditelnosti mezi jednotlivımi reprezentacemi datového modelu:

\begin{itemize}
	\item Vıvojáø dostane jako podklady z analızy systému UML class diagram datového modelu vytvoøeného v CASE nástroji. Z nìj mùe vygenerovat odpovídající Ecore model. Na základì Ecore modelu pak mùe vygenerovat tøídy implementující uvedenı model v jazyce Java. I kdy nìkteré CASE nástroje umoòují pøímé generování jednoduché implementace z UML class diagramu, implementace EMF modelù má nìkteré další potenciální vıhody (získané za cenu bìhovıch závislostí na EMF), které budou rozebrány dále.
	
	\item Øeknìme, e implementujeme komunikaci s externím systémem pomocí XML zpráv. Pokud máme k dané zprávì k dispozici XML schéma, nebo si XML schéma vytvoøíme, mùeme na základì tohoto XML schématu vytvoøit Ecore model a z nìj vygenerovat implementaci datového modelu v Javì. Serializace vzniklého EMF modelu bude navíc validní podle zdrojového XML schématu a bude proto moné automaticky pøevést XML zprávu na Java objekty a naopak.
	
	\item Pokud zaèneme pøímo tvorbou Ecore modelu, máme monost z daného modelu vygenerovat XML schéma a implementovat tak komunikaci mezi dvìma systémy z druhé strany ne v pøedchozím pøípadì (nyní definujeme tìlo zprávy, pøedcházející pøípad vycházel právì z této definice). Mùeme také vygenerovat UML class diagram pro dokumentaèní úèely.
\end{itemize}

\noindent Jak ji bylo nastínìno, Java instance EMF modelù vygenerované podle vıchozích šablon z Ecore modelu\footnote{Samotné generování Java reprezentace EMF modelu je z velké míry konfigurovatelné a jednotlivé vısledky se tak mohou znaènì lišit podle konkrétních nastavení. Navíc je moné šablony pouité pro generování upravit a nebo vytvoøit své vlastní. My se však dále budeme zabıvat pouze Java reprezentacemi vzniklımi na základì vıchozích šablon.} mají bìhovou závislost na EMF. Všechny Java tøídy implementující tøídy z Ecore modelu rozšiøují jednu z implementací rozhraní \verb|EObject|. Toto rozhraní obsahuje mimo jiné reflektivní metody pro práci s modelem. Reflexe je v EMF velmi silnım nástrojem, kterı jde daleko za hranice standardní Java reflexe jak ve snadnosti pouití, tak v mnoství obsaenıch informací (za bìhu lze z kadého \verb|EObject|u získat jeho \verb|EClass| -- reprezentaci tøídy z Ecore modelu). Silná reflexe je pøitom klíèovım faktorem umoòujícím tvorbu generickıch nástrojù pro práci s modelem. Vedle reflektivních metod obsahují implementace \verb|EObject|u systém notifikací umoòující poslouchat na zmìny jednotlivıch atributù nebo referencí objektù. Podívejme se na nìkteré pøínosy uvedenıch mechanismù:

\begin{description} 
	\item[Automatická persistence EMF modelù] Kadı EMF model mùe bıt automaticky serializován do XML nebo XMI\footnote{XML Metadata Interchange (XMI) je standard OMG na vımìnu metadat skrze XML. Nejznámìjší aplikací XMI jsou serializace UML.} a následnì deserializován. Objekty serializované v rùznıch souborech se dokonce mohou vzájemnì referencovat pøi zachování transparentnosti pro klienty (pro naètení souboru s referencovanım objektem staèí na danı objekt v aplikaci poprvé pøistoupit, pro klienty se tak objektovı graf jeví propojenı bez ohledu na hranice jednotlivıch souborù). Další projekty vzniklé kolem jádra EMF pak umoòují persistenci v relaèní databázi (Teneo), nebo dokonce tvorbu distribuovanıch systémù s centrálním repozitáøem dat a mnostvím klientù, kteøí je paralelnì upravují a to vèetnì propagace distribuovanıch notifikací (CDO). Pro úèely pluginù Eclipse IDE je však persistence v XMI ve vìtšinì pøípadù naprosto dostateèná.
	
	\item[Pokroèilé monosti editace] Mnoho EMF modelù mùe bıt spravováno internì automatizovanımi systémy. Vedle nich však existuje skupina modelù upravovaná na základì uivatelského vstupu. Ve strukturovanıch editorech pøitom uivatel model upravuje pomocí rùznıch textovıch polí, combo boxù, seznamù, stromù a podobnì. Úkolem programátora pak je zajistit propagaci hodnot z tìchto vstupních polí do modelu a obrácenì. Toho lze prakticky docílit buï manuální synchronizací hodnot, která je u vìtšího poètu polí pomìrnì nároèná, nebo vyuitím databinding API. K pouití databinding API však datovı model musí podporovat notifikace na zmìny hodnot atributù. U klasického modelu mùeme tuto podporu pøidat ruènì, v pøípadì EMF modelù však tuto vlastnost dostáváme automaticky. Kromì toho identifikace vlastností objektù pro pouití s databinding API je v EMF typovì bezpeènìjší.
	
	Vedle monosti pouití databinding API existuje v EMF podpora pro editaci pomocí pøíkazù (command-based editing) a s tím související podpora pro undo a redo operace. Databinding lze pøitom zkonfigurovat tak, aby model neupravoval pøímo, ale právì pomocí pøíkazù a tak pouitím EMF modelù získáváme tuto jinak velmi sloitou funkcionalitu prakticky zdarma. Pøi úpravách modelu je navíc moné vyuít jednoduchıch transakcí, ve kterıch lze provést více zmìn modelu atomicky.
	
	\item[Mnoství generickıch nástrojù] Kolem EMF se vzniklo velké mnoství nejrùznìjších nástrojù, je v Eclipse komunitì zamìøené primárnì na vıvoj nástrojù pro vıvojáøe najdou široké uplatnìní. Najdeme zde transformaèní jazyky definující model-to-model transformace (ATL). Dále templating jazyky pro model-to-text transformace (Acceleo), frameworky pro tvorbu grafickıch editorù EMF modelù (GMF, Graphity) a dokonce projekt pro tvorbu infrastruktury pro vlastní Domain Specific Language (Xtext) -- na základì definice gramatiky jazyka dostaneme parser tvoøící syntaktickı strom v podobì EMF modelu a Eclipse editor pro danı jazyk. Kromì tìchto komplexních nástrojù EMF usnadòuje i nìkteré zdánlivì jednoduché úkoly, je nejsou ve standardní Javì snadno realizovatelné, jako napøíklad vytvoøení hluboké kopie objektu (tj. kopie daného objektu vèetnì kopií všech objektù dostupnıch pøes kompozitní vazby).
\end{description}

\noindent Vzhledem k uvedenım benefitùm je EMF pomìrnì jasnou volbou pro realizaci novıch datovıch modelù v rámci pluginù Eclipse IDE. I kdy zdaleka ne všechny modely vyuijí všech vlastností EMF (nìkteré modely napøíklad nevyadují persistenci), v budoucích verzích mohou pøijít nové poadavky a vyuití EMF od zaèátku mùe budoucí implementaci znaènì usnadnit. V~Eclipse komunitì je v poslední dobì znatelnı tlak na pøechod k EMF modelùm namísto proprietárních implementací i kvùli benefitùm plynoucím z konzistentního pouívání jedné technologie. Následující generace Eclipse RCP\footnote{V rámci simultánní releasu Eclipse Indigo v èervnu 2011 je stále hlavní verzí platformy \uv{souèasná generace} -- verze 3.7. Vedle ní je souèasnì uvolòována další generace Eclipse RCP ve verzi 4.1, která je stále zacílena pøedevším na vıvojáøe, aby mohli otestovat kompatibilitu svıch rozšíøení. U komunity velikosti Eclipse (souèástí Indigo release je 62 projektù s celkem 46 miliony øádky zdrojového kódu \citep{indigo-release-networkworld} a to stále pøedstavuje jen èást aktivních projektù) trvá pøechod na novou architekturu øadu let, i kdy je díky speciální compatibility-layer binárnì kompatibilní se souèasnou generací.} navíc pouívá EMF model k reprezentaci stavu GUI a na úroveò jednotlivıch editorù a view (jejich obsah ji modelován není).

\cleardoublepage
\chapter*{Závìr} \addcontentsline{toc}{chapter}{Závìr}
TODO: nìco na závìr... 

\begin{thebibliography}{99}

\bibitem{shreves10} SHREVES, Ric. \emph{2010 Open Source CMS Market Share Report} [online]. Bali, Indonesia : water\&stone, 10.12.2010 [cit. 2011-05-15]. Dostupné z WWW: \textless\url{http://www.waterandstone.com/book/2010-open-source-cms-market-share-report}\textgreater.

\bibitem{tiobe} TIOBE Software BV. \emph{TIOBE Programming Community Index for May 2011} [online]. 2011 [cit. 2011-05-22]. Dostupné z WWW: \textless\url{http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html}\textgreater.

\bibitem{phpfrmwpoll} SIRONI, Giorgio. \emph{The PHP frameworks poll results} [online]. 2011 [cit. 2011-05-22]. Dostupné z WWW: \textless\url{http://css.dzone.com/articles/php-frameworks-poll-results}\textgreater.

\bibitem{xdebugvim} Box.net, Inc. \emph{How to Debug PHP with Vim and XDebug on Linux} [online]. 2007 [cit. 2011-05-22]. Dostupné z WWW: \textless\url{http://tech.blog.box.net/2007/06/20/how-to-debug-php-with-vim-and-xdebug-on-linux/}\textgreater.

\bibitem{wp-pluginhowto} Wordpress.org. \emph{Writing a Plugin} [online]. 2011 [cit. 2011-05-24]. Dostupné z WWW: \textless\url{http://codex.wordpress.org/Writing_a_Plugin}\textgreater.

\bibitem{drupal-oop} Drupal.org. \emph{Drupal programming from an object-oriented perspective} [online]. 2011 [cit. 2011-05-25]. Dostupné z WWW: \textless\url{http://drupal.org/node/547518}\textgreater.

\bibitem{drupal-moduledev} Drupal.org. \emph{Module developer's guide} [online]. 2010 [cit. 2011-05-25]. Dostupné z WWW: \textless\url{http://drupal.org/developing/modules}\textgreater.

\bibitem{mastering-joomla} KENNARD, James. \emph{Mastering Joomla! 1.5 : Extension and Framework Development}. Birmingham : Packt Publishing, 2007. 470 s. ISBN 978-1-847192-82-0.

\bibitem{sample-component-manifest} Joomla.org. \emph{Components: xml installfile} [online]. 2011 [cit. 2011-05-25]. Dostupné z WWW: \textless\url{http://docs.joomla.org/Components:xml_installfile}\textgreater.

\bibitem{dreamweaver-cms} lynda.com. \emph{Working with CMS frameworks in Dreamweaver CS5 New Features from lynda.com} [online]. San Bruno (California) : YouTube, LLC, 11.04.2010 [cit. 2011-05-26]. Dostupné z WWW: \textless\url{http://www.youtube.com/watch?v=AflQ_N3Kl1Q&feature=player_embedded}\textgreater.

\bibitem{codelobster} CodeLobster Software. \emph{CodeLobster PHP Edition} [online]. 2011 [cit. 2011-05-26]. Dostupné z WWW: \textless\url{http://www.codelobster.com/}\textgreater.

\bibitem{d4e-drupal-groups} CHARLTON, Chris. \emph{Drupal plug-in for Eclipse IDE by XTND.US} [online]. Groups.drupal.org, 2011 [cit. 2011-05-26]. Dostupné z WWW: \textless\url{http://groups.drupal.org/node/39938}\textgreater.

\bibitem{d4e-eclipse-forums} CHARLTON, Chris. \emph{Drupal plug-in for PDT} [online]. Ottawa (Ontario, Canada) : Eclipse Foundation, Inc, 2011 [cit. 2011-05-26]. Dostupné z WWW: \textless\url{http://www.eclipse.org/forums/index.php?t=tree\&th=161152\&}\textgreater.

\bibitem{drupal-netbeans} NAIR, Sujit. \emph{NetBeans 6.5 Support for Drupal 6.x} [online]. Oracle Corporation, 2008 [cit. 2011-05-26]. Dostupné z WWW: \textless\url{http://plugins.netbeans.org/PluginPortal/faces/PluginDetailPage.jsp?pluginid=10859}\textgreater.

\bibitem{jeclipse-blog} PERMANA, Wim. \emph{JEclipse Soc Version} [online]. 2007 [cit. 2011-05-26]. Dostupné z WWW: \textless\url{http://kleq.web.ugm.ac.id/2007/08/20/jeclipse-soc-version/}\textgreater.

\bibitem{jeclipse-userguide} PERMANA, Wim. \emph{JECLIPSE User Guide} [online]. Nedatováno [cit. 2011-05-26]. Dostupné z WWW: \textless\url{http://kleq.web.ugm.ac.id/images/joomlaeclipse/userguide.pdf}\textgreater.

\bibitem{jcode} JoomlaCode. \emph{J!Code Project} [online]. New York : Open Source Matters, 2007 [cit. 2011-05-26]. Dostupné z WWW: \textless\url{http://joomlacode.org/gf/project/jcode/}\textgreater.

\bibitem{easyeclipse} nextB. \emph{EasyEclipse 1.3} [online]. Fairfax (Virginia) : Geeknet, 2011 [cit. 2011-05-26]. Dostupné z WWW: \textless\url{http://www.easyeclipse.org/site/home/index.html}\textgreater.

\bibitem{joomla-extensiondev} Joomla.org. \emph{Setting up your workstation for extension development} [online]. New York : Open Source Matters, 2011 [cit. 2011-05-28]. Dostupné z WWW: \textless\url{http://docs.joomla.org/Setting_up_your_workstation_for_extension_development}\textgreater.

\bibitem{pdtpackagedetails} The Eclipse Foundation. \emph{Eclipse for PHP Developers (Package details)} [online]. Ottawa (Ontario, Canada) : Eclipse Foundation, Inc, 2010 [cit. 2011-06-02]. Dostupné z WWW: \textless\url{http://www.eclipse.org/downloads/packages/eclipse-php-developers/heliossr2}\textgreater.

\bibitem{wiki-osgi} OSGi. \emph{In Wikipedia : the free encyclopedia} [online]. St. Petersburg (Florida) : Wikipedia Foundation, 25 February 2002, last modified on 12 June 2011 [cit. 2011-06-23]. Dostupné z WWW: \textless\url{http://en.wikipedia.org/wiki/OSGi}\textgreater.

\bibitem{osgi-spec-core} OSGi Alliance. \emph{OSGi Service Platform : Core Specification}. Release 4, Version 4.3. San Ramon (California) : OSGi Alliance, 2011. 352 s.

\bibitem{osgi-spec-compendium} OSGi Alliance. \emph{OSGi Service Platform : Service Compendium}. Release 4, Version 4.2. San Ramon (California) : OSGi Alliance, 2009. 850 s.

\bibitem{emf-bible} STEINBERG, Dave, et al. \emph{EMF: Eclipse Modeling Framework}. Second Edition. Boston (Massachussets) : Addison-Wesley Professional, 2008. 744 s. ISBN 978-0-321-33188-5.

\bibitem{indigo-release-networkworld} Network World, Inc. \emph{Eclipse's annual software release train arrives}. Framingham (Massachussets) : Network World, Inc., June 22, 2011 [cit. 2011-06-23]. Dostupné z WWW: \textless\url{http://www.networkworld.com/news/2011/062211-eclipses-annual-software-release-train.html}\textgreater.

\end{thebibliography}

\end{document}
